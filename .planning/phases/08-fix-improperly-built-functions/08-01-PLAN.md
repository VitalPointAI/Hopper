---
phase: 08-fix-improperly-built-functions
plan: 01
type: execute
---

<objective>
Add state persistence and non-blocking UI infrastructure to /verify-work command.

Purpose: Enable verification to survive interruptions (click-away, Escape, VSCode restart) and allow users to interact with chat during testing.
Output: VerifyWork command with persistent state and resumable verification flow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-fix-improperly-built-functions/08-CONTEXT.md

**Key files:**
@src/chat/commands/verifyWork.ts
@src/chat/commands/executePlan.ts (reference for state persistence pattern)
@src/chat/commands/types.ts

**Prior decisions:**
- 04-02: GlobalState for checkpoint state - persists execution state across VSCode restarts
- 05.1-03-FIX: vscode.window dialogs for interactive flow - Chat API doesn't support multi-turn

**Issue being fixed:**
- Verification stops if user clicks away or presses Escape
- No state persistence - progress lost on interruption
- User cannot interact with chat during verification
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add verification state types and persistence</name>
  <files>src/chat/commands/verifyWork.ts</files>
  <action>
Add VerificationState interface with fields:
- planPath: string (which plan being verified)
- phase: string, plan: string
- testItems: string[] (all tests)
- results: TestResult[] (completed results)
- currentIndex: number (which test is next)
- startedAt: string (ISO timestamp)
- pausedAt?: string (if paused)

Add persistence functions following executePlan.ts pattern:
- getVerificationStateKey(planPath: string): string - returns "hopper.verificationState.{planPath}"
- saveVerificationState(context, state): Promise<void>
- loadVerificationState(context, planPath): VerificationState | undefined
- clearVerificationState(context, planPath): Promise<void>

Update handleVerifyWork to:
1. Check for existing state at start - if found and has remaining tests, offer to resume
2. Save state after each test result (before moving to next test)
3. Clear state when all tests complete
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>VerificationState type defined, persistence functions work, state saved after each test</done>
</task>

<task type="auto">
  <name>Task 2: Replace blocking dialogs with non-blocking QuickPick</name>
  <files>src/chat/commands/verifyWork.ts</files>
  <action>
Replace the blocking showQuickPick calls in runInteractiveTests with non-blocking approach:

1. Use vscode.window.createQuickPick() instead of showQuickPick() to create a persistent picker
2. Set picker.ignoreFocusOut = true (keeps open when clicking elsewhere)
3. Use picker.onDidAccept and picker.onDidHide event handlers
4. When user clicks away (onDidHide without selection), save state and show "Verification paused" message
5. User can resume later with /verify-work (picks up from saved state)

For the result picker:
- Create QuickPick with same options (Pass/Fail/Partial/Skip)
- On accept: record result, save state, move to next test
- On hide (without accept): save state as "paused", inform user they can resume

For severity and description (only shown on Fail/Partial):
- Same pattern: createQuickPick/createInputBox with ignoreFocusOut
- If cancelled, default to "Major" severity and empty description (don't block flow)

Key: User clicking away pauses verification gracefully instead of losing progress.
  </action>
  <verify>Run /verify-work, click elsewhere, verify state persisted. Run /verify-work again, verify resume prompt appears.</verify>
  <done>Clicking away pauses instead of stops, state persisted, resume works</done>
</task>

<task type="auto">
  <name>Task 3: Add resume flow to handleVerifyWork</name>
  <files>src/chat/commands/verifyWork.ts</files>
  <action>
Update handleVerifyWork entry point to handle resume:

1. After finding summary files but before generating tests, check for saved state:
   ```typescript
   const savedState = loadVerificationState(extensionContext, summaryUri.fsPath);
   if (savedState && savedState.currentIndex < savedState.testItems.length) {
     // Offer resume
   }
   ```

2. If saved state exists with incomplete tests:
   - Show resume prompt: "Resume verification? X of Y tests completed."
   - Options: "Resume" (continue from currentIndex), "Start Over" (clear state, regenerate)
   - Use showQuickPick for this one-time choice (blocking OK here)

3. On Resume:
   - Restore testItems and results from saved state
   - Start runInteractiveTests from savedState.currentIndex
   - Display progress: "Resuming from test X of Y"

4. On Start Over:
   - Clear saved state
   - Generate fresh tests
   - Start from beginning

This ensures /verify-work seamlessly resumes interrupted sessions.
  </action>
  <verify>Start verification, pause at test 2, run /verify-work again, confirm resume prompt shows "Resume verification? 1 of N tests completed"</verify>
  <done>Resume flow works end-to-end, user can pick up where they left off</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] State persists when clicking away during test
- [ ] /verify-work offers resume when prior state exists
- [ ] Complete verification still works (all tests, results logged)
- [ ] State cleared after completion
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Verification survives click-away and VSCode restart
- Resume flow works seamlessly
</success_criteria>

<output>
After completion, create `.planning/phases/08-fix-improperly-built-functions/08-01-SUMMARY.md`
</output>
