---
phase: 08-fix-improperly-built-functions
plan: 01-FIX
type: fix
---

<objective>
Fix 2 UAT issues from plan 08-01.

Source: 08-01-ISSUES.md
Priority: 1 blocker, 1 major

**Core problem:** The current verify-work implementation uses VSCode QuickPick dialogs for interactive testing. While `ignoreFocusOut=true` keeps dialogs open when clicking away, it does NOT allow the user to type in the chat input while the dialog is visible. The only way to type is to dismiss the dialog, which loses context.

**Solution:** Replace QuickPick dialog flow with stream.button() based flow (same pattern as execute-plan checkpoints). Stream buttons allow the user to:
1. See the test in chat
2. Click a button to record result
3. Type questions in chat between button clicks
4. Resume seamlessly since state is persisted after each button click
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/08-fix-improperly-built-functions/08-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/08-fix-improperly-built-functions/08-01-PLAN.md

**Key files:**
@src/chat/commands/verifyWork.ts
@src/chat/commands/executePlan.ts (reference for button-based checkpoint pattern)
@src/chat/commands/types.ts

**Reference pattern from executePlan.ts:**
The checkpoint flow in executePlan uses stream.button() to present options, then the user clicks a button which invokes a registered command. This allows the user to type in chat before clicking.

**Key insight from UAT-002:**
The issue states user "cannot type in the chat to ask clarifying questions about a test without first hitting the Stop button." This is because QuickPick dialogs capture input focus. The solution is to NOT use dialogs at all - instead, stream the test content and buttons to the chat, and handle button clicks via registered commands.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix globalState persistence to survive reload</name>
  <files>src/chat/commands/verifyWork.ts</files>
  <action>
Debug and fix the globalState persistence issue. The current code looks correct but state is lost on reload.

Potential issues to investigate:
1. The key might be too long or contain invalid characters (file paths with slashes)
2. The state might not be getting saved synchronously before reload
3. The globalState might need explicit setKeysForSync

Fix approach:
1. Sanitize the storage key - replace slashes with underscores, limit length
2. Add `context.globalState.setKeysForSync()` call to ensure persistence across restarts
3. Add debug logging to trace save/load operations

Update getVerificationStateKey to create a clean, sync-safe key:
```typescript
function getVerificationStateKey(planPath: string): string {
  // Create clean key from plan path - just use phase-plan identifier
  const match = planPath.match(/(\d+(?:\.\d+)?)-(\d+)-SUMMARY\.md$/);
  if (match) {
    return `hopper.verificationState.${match[1]}-${match[2]}`;
  }
  // Fallback: hash the path to create a short key
  const hash = planPath.split('').reduce((a, b) => ((a << 5) - a + b.charCodeAt(0)) | 0, 0);
  return `hopper.verificationState.${Math.abs(hash)}`;
}
```

Add setKeysForSync in saveVerificationState to mark state for sync:
```typescript
async function saveVerificationState(
  context: vscode.ExtensionContext,
  state: VerificationState
): Promise<void> {
  const key = getVerificationStateKey(state.planPath);
  await context.globalState.update(key, state);
  // Mark key for sync to survive restarts
  context.globalState.setKeysForSync([key]);
}
```
  </action>
  <verify>npm run compile succeeds. Start verify-work, complete 1 test, reload VSCode window, run verify-work on same plan - should offer Resume.</verify>
  <done>State persists across VSCode reload</done>
</task>

<task type="auto">
  <name>Task 2: Replace QuickPick flow with button-based flow</name>
  <files>src/chat/commands/verifyWork.ts, src/extension.ts</files>
  <action>
Replace the blocking QuickPick dialog flow with stream.button() based flow that allows chat interaction between tests.

**1. Register a new command to handle test results:**

In extension.ts, register a command that handles button clicks:
```typescript
context.subscriptions.push(
  vscode.commands.registerCommand(
    'hopper.verifyWorkTestResult',
    async (planPath: string, testIndex: number, result: string) => {
      // This is called when user clicks a test result button
      // Load state, record result, save state
      // Then trigger continuation of verification
    }
  )
);
```

**2. Rewrite runInteractiveTests to use buttons instead of QuickPick:**

Instead of:
```typescript
const statusResult = await showNonBlockingQuickPick(...);
```

Do:
```typescript
// Stream the test
stream.markdown(`### Test ${i + 1} of ${testItems.length}\n\n`);
stream.markdown(`${testItem}\n\n`);
stream.markdown('**What is the result?**\n\n');

// Show buttons for each option
stream.button({
  command: 'hopper.verifyWorkTestResult',
  arguments: [planPath, i, 'pass'],
  title: '✓ Pass'
});
stream.button({
  command: 'hopper.verifyWorkTestResult',
  arguments: [planPath, i, 'fail'],
  title: '✗ Fail'
});
stream.button({
  command: 'hopper.verifyWorkTestResult',
  arguments: [planPath, i, 'partial'],
  title: '⚠ Partial'
});
stream.button({
  command: 'hopper.verifyWorkTestResult',
  arguments: [planPath, i, 'skip'],
  title: '⏭ Skip'
});

// Save state indicating waiting for result
state.currentIndex = i;
state.waitingForResult = true;
await saveVerificationState(extensionContext, state);

// Return early - command handler will continue flow
return { results: state.results, paused: false, waitingForButton: true };
```

**3. Update VerificationState interface:**

Add field to track that we're waiting for a button click:
```typescript
interface VerificationState {
  // ... existing fields
  waitingForResult?: boolean;  // True when buttons shown, awaiting click
  pendingSeverity?: boolean;   // True when awaiting severity for fail/partial
}
```

**4. Create command handler for test results:**

The hopper.verifyWorkTestResult command handler:
- Loads saved state
- If result is 'fail' or 'partial', show severity buttons and description input
- Records the result to state.results
- Saves state with currentIndex incremented
- If more tests remain, opens a new chat with @hopper /verify-work to continue
- If all tests done, opens chat with completion summary

**5. Handle severity selection similarly with buttons:**

For fail/partial, show severity buttons:
```typescript
stream.markdown('**How severe is this issue?**\n\n');
stream.button({ command: 'hopper.verifyWorkSeverity', arguments: [planPath, 'blocker'], title: 'Blocker' });
stream.button({ command: 'hopper.verifyWorkSeverity', arguments: [planPath, 'major'], title: 'Major' });
stream.button({ command: 'hopper.verifyWorkSeverity', arguments: [planPath, 'minor'], title: 'Minor' });
stream.button({ command: 'hopper.verifyWorkSeverity', arguments: [planPath, 'cosmetic'], title: 'Cosmetic' });
```

**Key benefit:** User can now type questions in chat between button clicks. The flow is:
1. /verify-work shows first test + buttons
2. User can type questions in chat (e.g., "what does this test mean?")
3. User clicks result button when ready
4. Command handler records result, triggers next test display
5. Repeat until all tests done

Remove showNonBlockingQuickPick and showNonBlockingInputBox functions since they're no longer needed.
  </action>
  <verify>Run /verify-work, verify buttons appear in chat. Type a question in chat - should work. Click a button, verify it records result and shows next test.</verify>
  <done>User can type in chat during verification, buttons work for recording results</done>
</task>

<task type="auto">
  <name>Task 3: Handle description input for fail/partial results</name>
  <files>src/chat/commands/verifyWork.ts</files>
  <action>
For fail/partial results, we need to capture a description. Since we can't use InputBox (it blocks chat), use the chat itself:

After user clicks severity button, show a message asking them to describe the issue:

```typescript
stream.markdown('**Please describe what went wrong:**\n\n');
stream.markdown('Type your description in the chat, then click Continue:\n\n');
stream.button({
  command: 'hopper.verifyWorkDescription',
  arguments: [planPath],
  title: 'Continue (with description in chat)'
});
stream.button({
  command: 'hopper.verifyWorkDescription',
  arguments: [planPath, ''],
  title: 'Skip Description'
});
```

The command handler reads the most recent user message from the chat history (if available) to capture the description. If not available or "Skip" was clicked, proceed with empty description.

Alternative simpler approach: Use a fixed description based on the severity:
- Blocker: "Feature completely unusable"
- Major: "Feature works but significant problem"
- Minor: "Small issue, feature still usable"
- Cosmetic: "Visual issue only"

This is simpler and avoids the complexity of capturing free-form input from chat.

Choose the simpler approach for this fix - use default descriptions based on severity. The user's context from the test description is already captured.
  </action>
  <verify>Click Fail on a test, select severity, verify result is recorded with appropriate default description</verify>
  <done>Fail/partial results captured with default descriptions</done>
</task>

<task type="auto">
  <name>Task 4: Wire up continuation flow via chat commands</name>
  <files>src/chat/commands/verifyWork.ts, src/extension.ts</files>
  <action>
Ensure the button-based flow properly continues through all tests:

1. When a result button is clicked, the command handler should:
   - Update state with the result
   - If more tests remain: Use vscode.commands.executeCommand to open a new chat message with @hopper /verify-work (the command will detect saved state and continue)
   - If all tests complete: Generate summary and write issues file

2. Update handleVerifyWork to detect "waiting for button" state:
   - If state exists and waitingForResult is true, this is a continuation
   - Display the next test with buttons
   - If currentIndex >= testItems.length, generate final summary

3. Clean up old dialog-based helper functions that are no longer needed:
   - Remove showNonBlockingQuickPick
   - Remove showNonBlockingInputBox
   - Update runInteractiveTests to be button-based

4. Test the full flow:
   - /verify-work starts and shows test 1 with buttons
   - User types question, gets answer
   - User clicks "Pass" button
   - New chat opens with @hopper /verify-work, shows test 2 with buttons
   - Repeat until all tests done
   - Summary displayed with issues file written
  </action>
  <verify>Complete a full verify-work flow from start to finish using buttons. Verify typing in chat works between tests. Verify final summary appears correctly.</verify>
  <done>Full button-based verification flow works end-to-end</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] State persists across VSCode reload (UAT-001 fixed)
- [ ] User can type in chat during verification (UAT-002 fixed)
- [ ] Button clicks properly record test results
- [ ] Full verification flow works end-to-end
- [ ] Issues file written correctly for fail/partial results
- [ ] Resume flow still works with button-based approach
</verification>

<success_criteria>
- All UAT issues from 08-01-ISSUES.md addressed
- Tests pass
- Ready for re-verification
</success_criteria>

<output>
After completion, create `.planning/phases/08-fix-improperly-built-functions/08-01-FIX-SUMMARY.md`
</output>
