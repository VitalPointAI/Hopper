---
phase: 11-log-paste-context
plan: 01
type: execute
---

<objective>
Enable seamless mid-execution context injection when users paste logs or information during plan execution.

Purpose: Currently, pasting content during /execute-plan terminates the flow and starts a fresh response. Users need to share command output, logs, or additional context without interrupting execution.

Output: Modified chat handler that detects active execution, absorbs pasted content as context, and continues execution with that context incorporated.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-log-paste-context/11-CONTEXT.md
@src/chat/hopperParticipant.ts
@src/chat/commands/executePlan.ts
@src/chat/executor/types.ts

**Key insight from 11-CONTEXT.md:**
- Non-interrupting flow is essential - pasting logs NEVER stops execution
- Smart context incorporation - pasted content informs current work
- Brief acknowledgment: "Got it, using that info..." then continue

**Existing patterns:**
- ExecutionState in globalState tracks plan execution (pausedAtCheckpoint, currentTaskIndex)
- detectActionIntent() pattern for recognizing action requests
- Direct action execution branch in hopperParticipant.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add active execution tracking to ExecutionState</name>
  <files>src/chat/executor/types.ts, src/chat/commands/executePlan.ts</files>
  <action>
1. Extend ExecutionState interface with new fields:
   - `activelyExecuting: boolean` - true when execution is in progress (not just paused at checkpoint)
   - `lastActivityTimestamp: number` - for stale execution detection

2. In executePlan.ts, add helper functions:
   - `setActiveExecution(context, planPath, taskIndex)` - marks execution as active
   - `clearActiveExecution(context)` - clears when execution completes/errors
   - `getActiveExecution(context)` - returns active execution state if any

3. Update execution flow in handleExecutePlan:
   - Call setActiveExecution at start of task execution loop
   - Clear on completion, cancellation, or error
   - Update timestamp during tool calls to keep state fresh

Avoid: Storing execution state in memory only - must use globalState for persistence across chat messages.
  </action>
  <verify>Build succeeds with `npm run build`</verify>
  <done>ExecutionState has activelyExecuting and lastActivityTimestamp fields. Helper functions exist for managing active execution state.</done>
</task>

<task type="auto">
  <name>Task 2: Detect and handle mid-execution context input</name>
  <files>src/chat/hopperParticipant.ts</files>
  <action>
1. Import getActiveExecution from executePlan.ts

2. In the chat handler (before slash command routing), add execution context detection:
   ```typescript
   // Check for active execution that could receive context
   const activeExecution = getActiveExecution(context);
   const isContextInput = activeExecution &&
     !request.command &&
     (Date.now() - activeExecution.lastActivityTimestamp) < 60000; // 60s window
   ```

3. When isContextInput is true:
   - Show brief acknowledgment: "Got it, incorporating that context..."
   - Store the pasted content in globalState with key `hopper.executionContext.${planPath}`
   - Return early with metadata indicating context was added

4. Create helper function:
   ```typescript
   async function storeExecutionContext(
     context: vscode.ExtensionContext,
     planPath: string,
     content: string
   ): Promise<void>
   ```

5. The stored context will be retrieved in executeWithTools on the next iteration.

Avoid:
- Trying to inject content into an already-running async function (not possible)
- Complex state synchronization between handler calls
  </action>
  <verify>Build succeeds with `npm run build`</verify>
  <done>Chat handler detects active execution and stores pasted content as execution context instead of starting new response.</done>
</task>

<task type="auto">
  <name>Task 3: Incorporate stored context into task execution</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
1. Add helper functions for execution context:
   ```typescript
   function getExecutionContext(context: vscode.ExtensionContext, planPath: string): string | undefined
   function clearExecutionContext(context: vscode.ExtensionContext, planPath: string): Promise<void>
   ```

2. In the task execution loop (inside the for loop over tasks), before calling executeWithTools:
   - Check for stored execution context
   - If found, append to the task prompt with clear formatting:
     ```
     **User-provided context:**
     ${storedContext}

     Use this information to inform your implementation.
     ```
   - Clear the context after incorporating (one-time use)

3. In the tool orchestration loop, after tool results:
   - Check for new execution context (user may paste while tools are running)
   - If found, add as a new user message to the conversation:
     ```typescript
     if (newContext) {
       messages.push(vscode.LanguageModelChatMessage.User(
         `Additional context from user:\n${newContext}\n\nContinue with this information.`
       ));
       await clearExecutionContext(ctx.extensionContext, planPath);
     }
     ```

Avoid: Polling for context in tight loops - check once per iteration, not continuously.
  </action>
  <verify>Build succeeds with `npm run build`</verify>
  <done>Stored execution context is incorporated into task prompts and tool orchestration loop. User-pasted content informs ongoing execution.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds without errors
- [ ] TypeScript compilation has no type errors
- [ ] ExecutionState interface extended properly
- [ ] Active execution tracking added to executePlan flow
- [ ] Chat handler detects mid-execution context
- [ ] Context is stored and incorporated into execution
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors or warnings
- When user pastes content during execution:
  1. Brief acknowledgment appears
  2. Execution continues (not terminated)
  3. Pasted content is used by the executing task
</success_criteria>

<output>
After completion, create `.planning/phases/11-log-paste-context/11-01-SUMMARY.md`
</output>
