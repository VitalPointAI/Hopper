# Phase 11 Plan 02: Execution Resume and Terminal Session Management

**Objective:** Fix two critical execution issues: (1) Execution restarts from the beginning instead of continuing from the paused task when user provides input, and (2) Long-running terminal processes (like servers) are killed when subsequent commands need to use them.

## Context

### Issue 1: Execution Restart from Beginning

When execution is stopped (via Stop button) to provide input, the user can paste context which triggers the "resume with context" flow in `hopperParticipant.ts`. However, the resume logic in `executePlan.ts` only uses `existingState.pausedAtCheckpoint` to determine the `startTaskIndex`, and cancelled executions don't set this flag.

**Root cause:**
- `saveCancelledExecution()` stores `planPath` and `taskIndex` in `CANCELLED_EXECUTION_KEY`
- `getCancelledExecution()` retrieves this info (valid for 5 minutes)
- When resuming, `hopperParticipant.ts` stores context and calls `handleExecutePlan`
- In `handleExecutePlan`:
  - `loadExecutionState()` returns state where `pausedAtCheckpoint = false` (not a checkpoint pause)
  - `startTaskIndex = 0` is never modified because the `if (existingState && existingState.pausedAtCheckpoint)` check fails
  - Execution restarts from task 1

**Fix:** When resuming from cancelled execution, pass the task index to `handleExecutePlan` and use it to set `startTaskIndex`.

### Issue 2: Terminal Session Management

The `hopper_runInTerminal` tool always disposes existing terminals with the same name before creating a new one. This is problematic for long-running processes:
- User starts a dev server in terminal "Hopper: npm"
- A subsequent task needs to run a test that uses the server
- The test task creates terminal "Hopper: npm test" which runs fine
- But if the plan needs to run another server-dependent command in the same terminal as before, it kills the server

**Root cause:**
- No concept of "persistent" vs "temporary" terminals
- No awareness of what a terminal is running (blocking vs completed)
- All terminals are treated the same way

**Fix:** Add terminal lifecycle management:
1. Track terminal purpose (server/background vs one-shot command)
2. For server terminals, always create with unique names or reuse without disposal
3. Add ability to detect if a command in a terminal has completed

## Scope

### In Scope
- Fix resume-from-cancelled-execution to continue from correct task index
- Add terminal session management for long-running processes
- Update terminal tool to support different terminal types
- Add terminal cleanup helper for plan completion

### Out of Scope
- Changing checkpoint-based pause/resume (working correctly)
- Terminal output capture (complex VSCode limitation)
- Cross-session terminal persistence

## Tasks

### Task 1: Fix cancelled execution resume to use correct task index
**Type:** auto
**Action:**
1. Update `hopperParticipant.ts` to pass task index when resuming cancelled execution
2. Update `handleExecutePlan` in `executePlan.ts` to accept and use a `startFromTask` parameter
3. When `startFromTask` is provided, use it instead of relying solely on checkpoint state
4. Preserve completed task tracking when resuming mid-execution

**Files:**
- `src/chat/hopperParticipant.ts`
- `src/chat/commands/executePlan.ts`

**Verification:**
- Execution can be stopped mid-plan
- User can paste context
- Execution continues from the paused task, not from the beginning

### Task 2: Add terminal session management infrastructure
**Type:** auto
**Action:**
1. Add terminal types: `server` (long-running, don't dispose) and `command` (one-shot, can dispose)
2. Extend `managedTerminals` Map to track terminal metadata (type, command, started time)
3. Add `isTerminalBusy()` helper to check if terminal has an active process
4. Update `hopper_runInTerminal` input schema to include optional `keepAlive: boolean` parameter
5. When `keepAlive: true`, don't dispose existing terminal - create with unique suffix instead
6. Add `hopper_disposeTerminal` tool for explicit cleanup

**Files:**
- `src/tools/terminalTools.ts`

**Verification:**
- `hopper_runInTerminal` with `keepAlive: true` creates persistent terminal
- Multiple commands can reference server terminals without killing them
- `hopper_disposeTerminal` can clean up specific terminals

### Task 3: Update execution to clean up terminals on completion
**Type:** auto
**Action:**
1. Export `cleanupTemporaryTerminals()` function that disposes non-keepAlive terminals
2. Call cleanup at end of successful plan execution
3. Keep server/background terminals running for user interaction
4. Add terminal status to execution summary

**Files:**
- `src/tools/terminalTools.ts`
- `src/chat/commands/executePlan.ts`

**Verification:**
- Temporary terminals are cleaned up after plan completion
- Server terminals remain active
- User can see which terminals are still running

### Task 4: Checkpoint - Verify execution resume works correctly
**Type:** checkpoint:human-verify
**What was built:** Fixed execution resume to continue from correct task instead of restarting
**How to verify:**
1. Start `/execute-plan` on a plan with multiple tasks
2. Click Stop button after task 2 or 3 completes
3. Paste some context text in the chat
4. Verify execution continues from where it stopped, not from task 1
5. Check that previously completed tasks are not re-executed

### Task 5: Checkpoint - Verify terminal management works correctly
**Type:** checkpoint:human-verify
**What was built:** Terminal session management for long-running processes
**How to verify:**
1. Run a plan that starts a dev server (e.g., `npm run dev`)
2. The server terminal should stay running
3. Subsequent commands should not kill the server
4. Run `hopper_disposeTerminal` to clean up when done
5. Verify server terminal can be explicitly closed

## Verification Criteria

### Execution Resume
- [ ] Stopping execution and providing context continues from paused task
- [ ] Task index is correctly preserved across stop/resume cycle
- [ ] Completed tasks are tracked and not re-executed
- [ ] Multiple stop/resume cycles work correctly

### Terminal Management
- [ ] Server terminals persist across command invocations
- [ ] One-shot command terminals can be reused or disposed
- [ ] Explicit terminal cleanup via tool works
- [ ] Plan completion cleans up temporary terminals
- [ ] Server terminals remain for user interaction after plan

## Technical Notes

### Execution Resume Implementation

In `hopperParticipant.ts`, modify the resume flow:
```typescript
// Instead of just storing context, pass task index
const resumeCtx: CommandContext = {
  request: {
    ...request,
    prompt: `${cancelledExecution.planPath} --from-task=${cancelledExecution.taskIndex}`,
    command: 'execute-plan'
  },
  // ... rest of context
};
```

In `executePlan.ts`, parse and use the task index:
```typescript
// Parse --from-task if present
const fromTaskMatch = promptText.match(/--from-task=(\d+)/);
const resumeFromTask = fromTaskMatch ? parseInt(fromTaskMatch[1], 10) : null;

if (resumeFromTask !== null) {
  startTaskIndex = resumeFromTask;
  stream.markdown(`**Resuming from task ${resumeFromTask + 1}...**\n\n`);
}
```

### Terminal Management Implementation

Extend terminal tracking:
```typescript
interface ManagedTerminalInfo {
  terminal: vscode.Terminal;
  type: 'server' | 'command';
  command: string;
  createdAt: number;
  keepAlive: boolean;
}

const managedTerminals: Map<string, ManagedTerminalInfo> = new Map();
```

## Risks

1. **State corruption on VSCode restart** - globalState may be lost; mitigation: document that resume only works within same session
2. **Terminal detection limitations** - VSCode doesn't expose terminal process state; mitigation: use naming conventions and keepAlive flag
3. **Plan-specific terminal naming** - Multiple plans may clash; mitigation: include plan identifier in terminal names

## Dependencies

- Phase 11 Plan 01 (mid-execution context injection) - provides the context storage infrastructure
