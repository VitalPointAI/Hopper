---
phase: 01.5.2-dual-auth
plan: 03
type: execute
---

<objective>
Update Stripe subscription flow to work with OAuth users (no NEAR wallet required for fiat payments).

Purpose: Allow OAuth-authenticated users to subscribe via Stripe without needing a NEAR wallet.
Output: Updated checkout flow, webhook handler writes to USER_LICENSES KV, upgrade modal with auth-aware payment flow.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.5.2-dual-auth/01.5.2-DESIGN.md (architecture design)

# Prior work
@.planning/phases/01.5.2-dual-auth/01.5.2-01-SUMMARY.md (OAuth handlers)
@.planning/phases/01.5.2-dual-auth/01.5.2-02-SUMMARY.md (Extension auth)
@.planning/phases/01.5-licensing/01.5-02-SUMMARY.md (original Stripe integration)

# Key source files
@workers/license-api/src/handlers/stripe-webhook.ts (webhook handler)
@workers/license-api/src/handlers/checkout.ts (checkout session creation)
@workers/license-api/src/services/subscription-store.ts (KV storage)
@src/licensing/upgradeModal.ts (upgrade webview)

**Tech stack available:** Stripe SDK, Hono, KV namespaces, JWT auth
**Established patterns:**
- Customer metadata for user identification
- KV for subscription records
- Webhook signature verification

**Constraining decisions:**
- Design doc: OAuth users license stored in USER_LICENSES KV (not NEAR contract)
- Design doc: Crypto users continue to use NEAR contract
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OAuth license check endpoint to Worker</name>
  <files>workers/license-api/src/handlers/license-check.ts, workers/license-api/src/index.ts</files>
  <action>
1. Create `workers/license-api/src/handlers/license-check.ts`:
   ```typescript
   import type { Context } from 'hono';
   import type { Env, OAuthUserLicense } from '../types';

   /**
    * Check license status for authenticated user
    * JWT token in Authorization header determines user
    */
   export async function handleLicenseCheck(c: Context<{ Bindings: Env }>): Promise<Response> {
     const env = c.env;
     const authHeader = c.req.header('Authorization');

     if (!authHeader?.startsWith('Bearer ')) {
       return c.json({ error: 'Missing authorization' }, 401);
     }

     const token = authHeader.slice(7);

     // Verify JWT and extract user
     try {
       const payload = await verifyJwt(token, env.ADMIN_SECRET);

       // Check auth type - wallet users should check NEAR contract directly
       if (payload.type === 'user') {
         // Wallet user - they should check contract, but we can proxy
         return c.json({
           isLicensed: false,
           expiresAt: null,
           message: 'Wallet users should check NEAR contract directly',
         });
       }

       // OAuth user - check USER_LICENSES KV
       const userId = payload.sub;  // oauth:{provider}:{id}
       const record = await env.USER_LICENSES.get(userId, 'json') as OAuthUserLicense | null;

       if (!record || !record.licenseExpiry) {
         return c.json({ isLicensed: false, expiresAt: null });
       }

       const now = Date.now();
       const isLicensed = record.licenseExpiry > now;

       return c.json({
         isLicensed,
         expiresAt: isLicensed ? record.licenseExpiry : null,
       });
     } catch (error) {
       console.error('JWT verification failed:', error);
       return c.json({ error: 'Invalid token' }, 401);
     }
   }

   // JWT verification helper (same pattern as admin-wallet-auth.ts)
   async function verifyJwt(token: string, secret: string): Promise<any> {
     const [headerB64, payloadB64, signatureB64] = token.split('.');

     // Verify signature
     const encoder = new TextEncoder();
     const key = await crypto.subtle.importKey(
       'raw',
       encoder.encode(secret),
       { name: 'HMAC', hash: 'SHA-256' },
       false,
       ['verify']
     );

     const signatureData = Uint8Array.from(atob(signatureB64.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));
     const valid = await crypto.subtle.verify(
       'HMAC',
       key,
       signatureData,
       encoder.encode(`${headerB64}.${payloadB64}`)
     );

     if (!valid) {
       throw new Error('Invalid signature');
     }

     // Decode and check expiry
     const payload = JSON.parse(atob(payloadB64.replace(/-/g, '+').replace(/_/g, '/')));
     if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {
       throw new Error('Token expired');
     }

     return payload;
   }
   ```

2. Register route in `index.ts`:
   ```typescript
   app.get('/api/license/check', async (c) => {
     const { handleLicenseCheck } = await import('./handlers/license-check');
     return handleLicenseCheck(c);
   });
   ```
  </action>
  <verify>
- `npm run build` succeeds in workers/license-api
- `npx wrangler dev` starts
- `curl http://localhost:8787/api/license/check` returns 401 (no auth)
  </verify>
  <done>
- /api/license/check endpoint created
- JWT verification extracts user from token
- Returns license status from USER_LICENSES KV
  </done>
</task>

<task type="auto">
  <name>Task 2: Update checkout handler for OAuth users</name>
  <files>workers/license-api/src/handlers/checkout.ts</files>
  <action>
1. Update checkout handler to accept JWT auth instead of/alongside NEAR account:
   ```typescript
   export async function handleCheckout(c: Context<{ Bindings: Env }>): Promise<Response> {
     const env = c.env;
     const body = await c.req.json<{
       near_account_id?: string;  // For wallet users (existing)
       // OR Authorization header with JWT for OAuth users
     }>();

     // Check for JWT auth first (OAuth users)
     const authHeader = c.req.header('Authorization');
     let userId: string;
     let email: string | undefined;
     let isOAuthUser = false;

     if (authHeader?.startsWith('Bearer ')) {
       const token = authHeader.slice(7);
       try {
         const payload = await verifyJwt(token, env.ADMIN_SECRET);
         userId = payload.sub;  // oauth:{provider}:{id}
         isOAuthUser = payload.type === 'oauth';

         // Get email from stored user profile
         const userRecord = await env.USER_LICENSES.get(userId, 'json') as OAuthUserLicense | null;
         email = userRecord?.email;
       } catch {
         return c.json({ error: 'Invalid token' }, 401);
       }
     } else if (body.near_account_id) {
       // Wallet user (existing flow)
       userId = body.near_account_id;
       isOAuthUser = false;
     } else {
       return c.json({ error: 'Authentication required' }, 401);
     }

     const stripe = new Stripe(env.STRIPE_SECRET_KEY, { ... });

     // Create checkout session
     const session = await stripe.checkout.sessions.create({
       mode: 'subscription',
       payment_method_types: ['card'],
       line_items: [{
         price: env.STRIPE_PRICE_ID,
         quantity: 1,
       }],
       success_url: `${env.APP_URL}/success?session_id={CHECKOUT_SESSION_ID}`,
       cancel_url: `${env.APP_URL}/cancel`,
       customer_email: email,  // Pre-fill for OAuth users
       metadata: {
         user_id: userId,
         auth_type: isOAuthUser ? 'oauth' : 'wallet',
         // Keep near_account_id for wallet users
         near_account_id: isOAuthUser ? undefined : userId,
       },
     });

     return c.json({ url: session.url });
   }
   ```

2. Add verifyJwt import or inline (same as license-check.ts)
  </action>
  <verify>
- `npm run build` succeeds
- Checkout handler accepts both JWT and near_account_id
  </verify>
  <done>
- Checkout creates sessions for both OAuth and wallet users
- Session metadata includes auth_type for webhook routing
- OAuth users get email pre-filled
  </done>
</task>

<task type="auto">
  <name>Task 3: Update webhook handler for OAuth users</name>
  <files>workers/license-api/src/handlers/stripe-webhook.ts, workers/license-api/src/services/oauth-license-store.ts</files>
  <action>
1. Create `workers/license-api/src/services/oauth-license-store.ts`:
   ```typescript
   import type { Env, OAuthUserLicense } from '../types';

   /**
    * Grant license to OAuth user by updating USER_LICENSES KV
    */
   export async function grantOAuthLicense(
     kv: KVNamespace,
     userId: string,  // oauth:{provider}:{id}
     durationDays: number,
     stripeCustomerId?: string
   ): Promise<{ success: boolean; expiresAt: number }> {
     // Get existing record
     const existing = await kv.get(userId, 'json') as OAuthUserLicense | null;

     if (!existing) {
       console.error(`No OAuth user record for ${userId}`);
       return { success: false, expiresAt: 0 };
     }

     // Calculate new expiry (extend from max of current expiry or now)
     const now = Date.now();
     const currentExpiry = existing.licenseExpiry ?? now;
     const baseTime = Math.max(currentExpiry, now);
     const newExpiry = baseTime + durationDays * 24 * 60 * 60 * 1000;

     // Update record
     const updated: OAuthUserLicense = {
       ...existing,
       licenseExpiry: newExpiry,
       stripeCustomerId: stripeCustomerId ?? existing.stripeCustomerId,
       updatedAt: now,
     };

     await kv.put(userId, JSON.stringify(updated));
     console.log(`Granted ${durationDays}-day license to OAuth user ${userId}, expires: ${new Date(newExpiry).toISOString()}`);

     return { success: true, expiresAt: newExpiry };
   }

   /**
    * Get OAuth user license expiry
    */
   export async function getOAuthLicenseExpiry(
     kv: KVNamespace,
     userId: string
   ): Promise<number | null> {
     const record = await kv.get(userId, 'json') as OAuthUserLicense | null;
     return record?.licenseExpiry ?? null;
   }
   ```

2. Update `handleInvoicePaid()` in stripe-webhook.ts:
   ```typescript
   async function handleInvoicePaid(env: Env, stripe: Stripe, event: Stripe.Event): Promise<void> {
     const invoice = event.data.object as Stripe.Invoice;
     // ... existing validation ...

     const customer = await stripe.customers.retrieve(customerId);
     if (customer.deleted) return;

     // Check auth type from metadata
     const authType = customer.metadata?.auth_type;
     const userId = customer.metadata?.user_id;

     if (!userId) {
       console.error(`No user_id in customer ${customerId} metadata`);
       return;
     }

     const durationDays = parseInt(env.LICENSE_DURATION_DAYS, 10) || 30;

     if (authType === 'oauth') {
       // OAuth user: grant license in USER_LICENSES KV
       const { grantOAuthLicense } = await import('../services/oauth-license-store');
       const result = await grantOAuthLicense(env.USER_LICENSES, userId, durationDays, customerId);

       if (!result.success) {
         throw new Error('OAuth license grant failed');
       }

       console.log(`Granted ${durationDays}-day license to OAuth user ${userId}`);
     } else {
       // Wallet user: grant license on NEAR contract (existing flow)
       const nearAccountId = customer.metadata?.near_account_id ?? userId;
       const result = await grantLicense(env, nearAccountId, durationDays);

       if (!result.success) {
         throw new Error(`NEAR license grant failed: ${result.error}`);
       }

       console.log(`Granted ${durationDays}-day license to ${nearAccountId}, tx: ${result.txHash}`);
     }

     // Update subscription record (same for both)
     // ... existing record saving ...
   }
   ```
  </action>
  <verify>
- `npm run build` succeeds
- oauth-license-store.ts exports correctly
- Webhook handler compiles without errors
  </verify>
  <done>
- Webhook routes to correct license store based on auth_type
- OAuth users get license in USER_LICENSES KV
- Wallet users continue to use NEAR contract
- Both paths update subscription records
  </done>
</task>

<task type="auto">
  <name>Task 4: Update upgrade modal for payment-first flow</name>
  <files>src/licensing/upgradeModal.ts</files>
  <action>
Update upgrade modal to show auth options when payment is selected (not require auth upfront):

1. Update constructor to accept auth status:
   ```typescript
   private constructor(
     panel: vscode.WebviewPanel,
     extensionUri: vscode.Uri,
     private authSession: AuthSession | null,  // Can be null (not authenticated)
     private context: vscode.ExtensionContext
   ) { ... }
   ```

2. Update `show()` static method:
   ```typescript
   public static show(context: vscode.ExtensionContext, authSession: AuthSession | null): void {
     // ... create panel ...
     UpgradeModalPanel.currentPanel = new UpgradeModalPanel(
       panel,
       context.extensionUri,
       authSession,
       context
     );
   }
   ```

3. Update HTML to show different flows:
   - If authenticated: Show current two-card layout
   - If not authenticated: Show "Sign in to subscribe" with auth options

4. Update Stripe checkout handler:
   ```typescript
   private async handleStripeCheckout(): Promise<void> {
     if (!this.authSession) {
       // Not authenticated - need to auth first
       // Show quick pick in VSCode (webview can't do this)
       this.panel.webview.postMessage({ command: 'need-auth', paymentType: 'stripe' });
       return;
     }

     // Authenticated - proceed with checkout
     const apiUrl = ...;
     const response = await fetch(`${apiUrl}/api/checkout`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
         // Include JWT for OAuth users
         ...(this.authSession.authType === 'oauth' ? {
           'Authorization': `Bearer ${this.authSession.token}`
         } : {}),
       },
       body: JSON.stringify({
         // Include NEAR account for wallet users
         ...(this.authSession.authType === 'wallet' ? {
           near_account_id: this.authSession.userId
         } : {}),
       }),
     });
     // ... rest of handler ...
   }
   ```

5. Handle 'need-auth' message by triggering auth flow:
   ```typescript
   // In message handler
   case 'need-auth':
     // Close modal and trigger auth
     const authManager = licenseValidator?.getAuthManager();
     if (authManager) {
       const paymentType = message.paymentType;
       // Auth then redirect to checkout
       // Store pending payment intent
       await this.context.globalState.update('specflow.pendingPayment', paymentType);
       // Trigger OAuth
       if (paymentType === 'stripe') {
         // Offer Google/GitHub for Stripe (card) payments
         await showAuthPicker();
       } else {
         // Wallet for crypto
         await authManager.startAuth();
       }
     }
     this.dispose();
     break;
   ```

6. Update account info display:
   ```typescript
   <div class="account-info">
     ${this.authSession
       ? `Licensing for: <strong>${this.authSession.displayName ?? this.authSession.userId}</strong>`
       : 'Sign in to subscribe'}
   </div>
   ```
  </action>
  <verify>
- `npm run build` succeeds
- Upgrade modal renders correctly when not authenticated
- Stripe checkout sends JWT for OAuth users
  </verify>
  <done>
- Upgrade modal works when not authenticated
- Payment buttons trigger auth flow if needed
- Checkout includes JWT for OAuth users
- Account display shows displayName for OAuth users
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds for both extension and worker
- [ ] `npx tsc --noEmit` passes in both directories
- [ ] Worker `/api/license/check` endpoint exists
- [ ] Worker `/api/checkout` accepts JWT auth
- [ ] Upgrade modal compiles without errors
</verification>

<success_criteria>
- All 4 tasks completed
- OAuth users can check license via API endpoint
- Checkout accepts both JWT (OAuth) and near_account_id (wallet)
- Webhook routes to correct license store
- Upgrade modal handles unauthenticated users
</success_criteria>

<output>
After completion, create `.planning/phases/01.5.2-dual-auth/01.5.2-03-SUMMARY.md`:

# Phase 01.5.2 Plan 03: Stripe Flow Updates Summary

**[Substantive one-liner describing OAuth-compatible checkout and webhook updates]**

## Accomplishments
- [Key outcomes]

## Files Created/Modified
- [List with descriptions]

## Decisions Made
- [Any decisions during implementation]

## Issues Encountered
- [Problems and resolutions, or "None"]

## Next Step
Ready for 01.5.2-04-PLAN.md (Testing and validation)

---
*Phase: 01.5.2-dual-auth*
*Completed: [date]*
</output>
