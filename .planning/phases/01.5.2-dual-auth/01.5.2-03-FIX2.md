# Phase 01.5.2 Plan 03 FIX2: Streamlined Payment Flows

**Issue:** Payment flows require multiple browser round-trips (auth → return → checkout → return)
**Discovered:** 2026-01-15 (UAT discussion)
**Severity:** UX Blocker

## Problem

Current flow when unauthenticated user clicks Subscribe:

**Crypto (worst case):**
1. Click Subscribe → browser opens for NEAR wallet auth → return to VSCode
2. Modal reopens → click "Pay with Crypto" → browser opens payment page
3. Connect wallet AGAIN on payment page → pay → return to VSCode

**Stripe:**
1. Click Subscribe → browser opens for OAuth → return to VSCode
2. Modal reopens → click "Subscribe with Card" → browser opens Stripe → pay → return

**Expected:** Click Subscribe → go to browser once → connect/auth + pay → return to VSCode

## Solution

### Crypto Flow (Primary Fix)

Remove the requirement for wallet auth in VSCode before going to payment page. The payment page already has wallet connection built-in via `@hot-labs/near-connect`.

**New flow:**
1. Click "Subscribe" (crypto) in modal → calls `/api/crypto/subscribe/init` with session ID
2. Worker creates pending subscription with session ID (no nearAccountId yet)
3. Opens payment page → user connects wallet + pays
4. Payment confirmation links subscription to wallet account
5. Success page redirects to VSCode with wallet authentication

**Key changes:**
- New endpoint: `POST /api/crypto/subscribe/init` (no nearAccountId required)
- Update payment page to capture wallet account on connection
- Update confirm endpoint to accept wallet account + link subscription
- Success redirect includes auth callback to VSCode

### Stripe Flow (Secondary Fix)

For OAuth users, Stripe can collect email during checkout. We don't need to authenticate first.

**New flow:**
1. Click "Subscribe" (card) in modal → calls `/api/checkout` with session ID
2. Worker creates checkout session (customer created on webhook)
3. Opens Stripe checkout → user enters email + pays
4. Webhook creates customer with email, grants license
5. Success page redirects to VSCode with OAuth session

**Note:** This requires creating the user record on successful payment rather than upfront.

## Tasks

### Task 1: Create session-based crypto subscription init

**File:** `workers/license-api/src/handlers/crypto-subscribe.ts`

Add new handler for anonymous subscription initialization:

```typescript
/**
 * POST /api/crypto/subscribe/init
 * Initialize crypto subscription without requiring wallet auth
 * Returns payment page URL where user will connect wallet and pay
 */
export async function handleCryptoSubscribeInit(
  c: Context<{ Bindings: Env }>
): Promise<Response> {
  try {
    const body = await c.req.json<{ sessionId?: string }>();

    // Generate session ID if not provided
    const sessionId = body.sessionId || crypto.randomUUID();

    // Create NEAR Intents deposit address
    const monthlyAmountUsd = c.env.CRYPTO_MONTHLY_USD;
    const intentResult = await createSubscriptionIntent(
      c.env,
      sessionId, // Use session ID as temporary identifier
      monthlyAmountUsd
    );

    // Store pending subscription with session ID (no nearAccountId yet)
    const subscription: CryptoSubscription = {
      nearAccountId: '', // Will be set when wallet connects
      sessionId,
      intentId: intentResult.intentId,
      monthlyAmountUsd,
      billingDay: getDefaultBillingDay(),
      status: 'pending',
      retryCount: 0,
      lastChargeDate: null,
      nextChargeDate: null,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    await saveCryptoSubscription(c.env.CRYPTO_SUBSCRIPTIONS, subscription);

    // Return payment page URL
    const baseUrl = c.req.url.replace(/\/api\/crypto\/subscribe\/init$/, '');
    const paymentUrl = `${baseUrl}/pay/${encodeURIComponent(intentResult.intentId)}`;

    return c.json({
      intentId: intentResult.intentId,
      paymentUrl,
      sessionId,
    }, 201);
  } catch (error) {
    console.error('Error initializing crypto subscription:', error);
    return c.json({ error: 'Failed to initialize subscription' }, 500);
  }
}
```

### Task 2: Update payment page to capture wallet on connect

**File:** `workers/license-api/src/handlers/crypto-payment-ui.ts`

Update the payment page JavaScript to:
1. Capture connected wallet account ID
2. Store it with the subscription on the server
3. Include account ID in confirm call

```javascript
// After wallet connects, store the account with the subscription
async function handlePayment() {
  // ... existing wallet connection code ...

  const { accounts } = await connector.getConnectedWallet();
  connectedAccountId = accounts[0].accountId;

  // Link wallet to subscription BEFORE payment
  await fetch('/api/crypto/subscribe/link', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      intentId,
      nearAccountId: connectedAccountId
    })
  });

  // ... continue with payment ...
}
```

### Task 3: Add wallet linking endpoint

**File:** `workers/license-api/src/handlers/crypto-subscribe.ts`

```typescript
/**
 * POST /api/crypto/subscribe/link
 * Link wallet account to pending subscription
 */
export async function handleCryptoSubscribeLink(
  c: Context<{ Bindings: Env }>
): Promise<Response> {
  const body = await c.req.json<{ intentId: string; nearAccountId: string }>();

  if (!body.intentId || !body.nearAccountId) {
    return c.json({ error: 'intentId and nearAccountId required' }, 400);
  }

  const subscription = await getCryptoSubscriptionByIntentId(
    c.env.CRYPTO_SUBSCRIPTIONS,
    body.intentId
  );

  if (!subscription) {
    return c.json({ error: 'Subscription not found' }, 404);
  }

  if (subscription.status !== 'pending') {
    return c.json({ error: 'Subscription already processed' }, 409);
  }

  // Update subscription with wallet account
  subscription.nearAccountId = body.nearAccountId;
  subscription.updatedAt = new Date().toISOString();

  await saveCryptoSubscription(c.env.CRYPTO_SUBSCRIPTIONS, subscription);

  return c.json({ success: true });
}
```

### Task 4: Update confirm to include VSCode callback

**File:** `workers/license-api/src/handlers/crypto-subscribe.ts`

Update handleCryptoSubscribeConfirm to return a success URL that redirects to VSCode:

```typescript
// After successful payment confirmation
const vscodeCallback = `vscode://specflow.specflow/auth-callback?` +
  `type=wallet&` +
  `accountId=${encodeURIComponent(subscription.nearAccountId)}&` +
  `status=success`;

return c.json({
  success: true,
  license: { days: durationDays, expiresAt: expiresAt.toISOString() },
  redirectUrl: vscodeCallback,
});
```

### Task 5: Update payment page success handling

**File:** `workers/license-api/src/handlers/crypto-payment-ui.ts`

After confirm succeeds, redirect to VSCode:

```javascript
if (confirmResponse.ok && confirmData.success) {
  // Redirect to VSCode
  if (confirmData.redirectUrl) {
    window.location.href = confirmData.redirectUrl;
  } else {
    window.location.reload();
  }
}
```

### Task 6: Update upgrade modal for direct payment

**File:** `src/licensing/upgradeModal.ts`

Update handleCryptoCheckout to work without prior auth:

```typescript
private async handleCryptoCheckout(): Promise<void> {
  const config = vscode.workspace.getConfiguration('specflow');
  const apiUrl = config.get<string>('licenseApiUrl') ?? '...';

  try {
    vscode.window.showInformationMessage('Opening crypto payment...');

    // If authenticated with wallet, use existing flow
    if (this.authSession?.authType === 'wallet') {
      // ... existing authenticated flow ...
      return;
    }

    // For unauthenticated users, use new init flow
    const response = await fetch(`${apiUrl}/api/crypto/subscribe/init`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      throw new Error('Failed to initialize payment');
    }

    const data = await response.json() as { paymentUrl: string };
    await vscode.env.openExternal(vscode.Uri.parse(data.paymentUrl));
    this.dispose(); // Close modal
  } catch (error) {
    // ... error handling ...
  }
}
```

### Task 7: Register new routes

**File:** `workers/license-api/src/index.ts`

```typescript
app.post('/api/crypto/subscribe/init', async (c) => {
  const { handleCryptoSubscribeInit } = await import('./handlers/crypto-subscribe');
  return handleCryptoSubscribeInit(c);
});

app.post('/api/crypto/subscribe/link', async (c) => {
  const { handleCryptoSubscribeLink } = await import('./handlers/crypto-subscribe');
  return handleCryptoSubscribeLink(c);
});
```

## Files Modified

1. `workers/license-api/src/handlers/crypto-subscribe.ts` - Add init and link handlers
2. `workers/license-api/src/handlers/crypto-payment-ui.ts` - Update JS for wallet linking + redirect
3. `workers/license-api/src/index.ts` - Register new routes
4. `workers/license-api/src/types.ts` - Add sessionId to CryptoSubscription
5. `src/licensing/upgradeModal.ts` - Update handleCryptoCheckout for direct flow

## Verification

1. `npm run compile` succeeds for extension
2. `npm run build` succeeds for worker
3. Test flow:
   - Open upgrade modal (unauthenticated)
   - Click crypto Subscribe
   - Should open payment page directly (no VSCode wallet auth first)
   - Connect wallet on payment page
   - Pay
   - Should redirect to VSCode with wallet now authenticated

## Decision

| Decision | Rationale |
|----------|-----------|
| Session-based init | Allows creating subscription before wallet is known |
| Link before payment | Associates wallet before money moves for safety |
| VSCode redirect on success | Completes the auth loop after payment |

---
*Phase: 01.5.2-dual-auth*
*Plan: 03-FIX2*
*Status: Ready for execution*
