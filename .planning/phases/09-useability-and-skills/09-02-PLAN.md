---
phase: 09-useability-and-skills
plan: 02
type: execute
---

<objective>
Implement auto-retry logic for transient failures and auto-issue creation for persistent failures.

Purpose: In yolo mode, the AI should attempt recovery before giving up. If a task fails, try again with adjusted approach. If it still fails, log an issue automatically so nothing is silently lost.
Output: Resilient execution with automatic retry and issue logging.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./09-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-useability-and-skills/09-CONTEXT.md
@.planning/phases/09-useability-and-skills/09-01-SUMMARY.md

# Key files to modify:
@src/chat/commands/executePlan.ts
@src/chat/executor/index.ts

# Prior context:
- Plan 09-01 added output channel logging
- ISSUES.md format already established in project
- Transient failures include: network errors, rate limits, model timeouts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic for transient failures in tool execution</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
Add retry capability to the executeWithTools function:

1. Define transient error patterns at top of file:
   ```typescript
   const TRANSIENT_ERROR_PATTERNS = [
     /rate limit/i,
     /timeout/i,
     /network/i,
     /ECONNRESET/i,
     /ETIMEDOUT/i,
     /503/i,
     /429/i,
   ];

   function isTransientError(error: string): boolean {
     return TRANSIENT_ERROR_PATTERNS.some(pattern => pattern.test(error));
   }
   ```

2. In the tool invocation try/catch block, wrap with retry logic:
   - Max 2 retries (3 total attempts)
   - Only retry if isTransientError returns true
   - Log each retry attempt: `logger.warn(`Retry ${attempt}/3 for ${toolName}: ${errorMsg}`)`
   - Exponential backoff: wait 1s, then 2s between retries
   - Use `await new Promise(r => setTimeout(r, delay))` for delays

3. If all retries fail:
   - Log final error: `logger.error(`Tool ${toolName} failed after 3 attempts: ${errorMsg}`)`
   - Continue with error result (existing behavior)

4. For non-transient errors:
   - Do not retry, fail immediately (existing behavior)
   - Log: `logger.error(`Tool ${toolName} failed (non-retryable): ${errorMsg}`)`

Do NOT retry on user cancellation (check token.isCancellationRequested before retry).
  </action>
  <verify>
- Build succeeds: `npm run compile`
- Simulate transient error (disconnect network briefly during execution)
- Check output channel shows retry attempts
  </verify>
  <done>
- TRANSIENT_ERROR_PATTERNS defined
- isTransientError helper function exists
- Retry loop with max 3 attempts for transient errors
- Exponential backoff (1s, 2s) between retries
- Non-transient errors fail immediately
- All retries logged to output channel
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement auto-issue creation for failed tasks</name>
  <files>src/chat/commands/executePlan.ts, src/chat/issues/autoLog.ts</files>
  <action>
Create automatic issue logging when tasks fail:

1. Create src/chat/issues/autoLog.ts:
   ```typescript
   import * as vscode from 'vscode';

   export interface TaskFailure {
     planPath: string;
     taskId: number;
     taskName: string;
     error: string;
     phase: string;
     timestamp: Date;
   }

   export async function logTaskFailure(
     workspaceUri: vscode.Uri,
     failure: TaskFailure
   ): Promise<{ success: boolean; issueId?: string }> {
     // Read existing ISSUES.md or create new one
     // Generate issue ID: EXE-{phase}-{taskId} format
     // Append issue in standard format
     // Return the issue ID
   }
   ```

2. Implement logTaskFailure:
   - Read .planning/ISSUES.md (or create if missing)
   - Generate issue ID: `EXE-${phase}-${taskId}` (e.g., EXE-09-01)
   - Add new issue under "## Open Enhancements" section with:
     - **Discovered:** Execution of {planPath}
     - **Type:** Execution Failure
     - **Description:** Task "{taskName}" failed: {error}
     - **Impact:** Blocking (task did not complete)
     - **Suggested fix:** Review error, adjust plan or retry manually

3. Update executePlan.ts:
   - Import `logTaskFailure` from '../issues/autoLog'
   - After a task fails (in the catch block or when result.success is false):
     - Call logTaskFailure with failure details
     - Log to output channel: `logger.warn(`Issue logged: ${issueId}`)`
     - Show in chat: `stream.markdown(`*Issue logged: ${issueId}*\n\n`)`

4. Only log issues in yolo mode (user expects autonomous handling):
   - Check executionMode before logging
   - In guided/manual mode, user is already aware of failures

Do NOT duplicate issues â€” check if EXE-{phase}-{taskId} already exists before adding.
  </action>
  <verify>
- Build succeeds: `npm run compile`
- Force a task failure (e.g., invalid file path in plan)
- Check ISSUES.md has new EXE-XX-YY entry
- Output channel shows "Issue logged" message
  </verify>
  <done>
- src/chat/issues/autoLog.ts exists with logTaskFailure function
- Failed tasks in yolo mode auto-create issues
- Issue ID format: EXE-{phase}-{taskId}
- Duplicate prevention (check before adding)
- Integration with output channel logging
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] Transient errors trigger retry with backoff
- [ ] Failed tasks in yolo mode create issues in ISSUES.md
- [ ] Output channel shows retry attempts and issue creation
- [ ] No regressions in normal execution flow
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Retry logic handles transient failures gracefully
- Auto-issue creation works for persistent failures in yolo mode
</success_criteria>

<output>
After completion, create `.planning/phases/09-useability-and-skills/09-02-SUMMARY.md`
</output>
