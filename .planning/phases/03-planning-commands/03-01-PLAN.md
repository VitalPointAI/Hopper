---
phase: 03-planning-commands
plan: 01
type: execute
---

<objective>
Implement the /new-project command that creates PROJECT.md through guided conversation.

Purpose: Enable users to initialize a new SpecFlow project by answering prompts, generating a structured PROJECT.md file following GSD template conventions.

Output: Working /new-project command that:
- Prompts user for project details (name, description, core value, requirements, constraints)
- Generates PROJECT.md following GSD template
- Creates .planning directory structure
- Shows success message with next steps
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (from 02-03 SUMMARY frontmatter):
@.planning/phases/02-chat-participant/02-02-SUMMARY.md
@.planning/phases/02-chat-participant/02-03-SUMMARY.md

# Key source files:
@src/chat/commands/index.ts
@src/chat/commands/types.ts
@src/chat/context/projectContext.ts
@src/chat/specflowParticipant.ts

**Tech stack available:** Command routing pattern, CommandContext with stream/token/projectContext
**Established patterns:**
- CommandHandler returns ISpecflowResult with metadata
- stream.markdown() for output, stream.button() for actions
- vscode.workspace.fs for file operations
- formatContextForPrompt() for context injection

**Constraining decisions:**
- [02-02]: kebab-case command names matching VSCode conventions
- [02-03]: Direct file reading via vscode.workspace.fs (Chat Variables API still unstable)
- [02-03]: Content truncation at 2000 chars to avoid token limit issues

**GSD Templates to follow:**
@~/.claude/get-shit-done/templates/project.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create project generator service module</name>
  <files>src/chat/generators/projectGenerator.ts, src/chat/generators/types.ts</files>
  <action>
Create a project generator module that handles PROJECT.md creation:

1. In types.ts, define:
   - ProjectConfig interface with: name, description, coreValue, requirements (string[]), outOfScope (string[]), context, constraints (string[])
   - GeneratorResult interface with: success, filePath?, error?

2. In projectGenerator.ts:
   - createProjectMd(config: ProjectConfig): string - generates PROJECT.md content following GSD template
   - saveProject(workspaceUri: Uri, config: ProjectConfig): Promise<GeneratorResult> - creates .planning/ dir and writes PROJECT.md
   - Use GSD template structure: # [Name], ## What This Is, ## Core Value, ## Requirements (Validated/Active/Out of Scope), ## Context, ## Constraints, ## Key Decisions
   - Include "Last updated" footer with current date

Avoid: Don't use fs module directly - use vscode.workspace.fs for cross-platform compatibility.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- types.ts exports ProjectConfig and GeneratorResult interfaces
- projectGenerator.ts exports createProjectMd and saveProject functions
- createProjectMd returns properly formatted markdown following GSD template
- saveProject creates .planning directory and writes PROJECT.md
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /new-project command handler with conversation flow</name>
  <files>src/chat/commands/newProject.ts, src/chat/commands/index.ts</files>
  <action>
Create the /new-project command handler:

1. In newProject.ts, create handleNewProject handler that:
   - Checks if .planning already exists - if so, warn user and offer to view existing project
   - Uses stream.markdown() to prompt for each field sequentially
   - Reads user input from request.prompt (the text after /new-project)
   - If no prompt provided, explains what info is needed and asks user to provide project details
   - If prompt provided, uses the LLM to extract project details from user's description

2. The handler should:
   - Use ctx.request.model to access the LLM for parsing user input
   - Extract: project name, description, core value, requirements, constraints from user's text
   - Generate PROJECT.md using projectGenerator
   - Show success with clickable file reference using stream.reference()
   - Suggest next step: /create-roadmap

3. Update index.ts:
   - Import and register handleNewProject handler
   - Remove placeholder for new-project command

Implementation approach for LLM parsing:
- Send a structured prompt asking the LLM to extract fields from user's description
- Parse the response to build ProjectConfig
- If extraction fails or is incomplete, ask user for missing information

Avoid: Don't block on multi-turn conversation - accept all input in single prompt, ask for more in response if incomplete.
  </action>
  <verify>
- npm run compile succeeds
- In test workspace, invoke /new-project with a project description and verify PROJECT.md is created
  </verify>
  <done>
- handleNewProject registered in command registry
- Handler detects existing .planning and warns appropriately
- Handler uses LLM to extract project details from user prompt
- PROJECT.md created following GSD template
- Success message shows with file reference and next step suggestion
  </done>
</task>

<task type="auto">
  <name>Task 3: Add progress indicator and error handling</name>
  <files>src/chat/commands/newProject.ts</files>
  <action>
Enhance the command with progress feedback and robust error handling:

1. Add progress indicator during LLM processing:
   - stream.progress('Analyzing your project description...')
   - stream.progress('Generating PROJECT.md...')

2. Add error handling for:
   - Workspace not open: "Please open a workspace folder first"
   - File write failures: "Failed to create PROJECT.md: [error]"
   - LLM parsing failures: Show what was extracted, ask for missing fields

3. Improve user experience:
   - If user provides minimal input, generate reasonable defaults and show what was assumed
   - Format output nicely with sections for what was created
   - Include button to open the created PROJECT.md file

Avoid: Don't fail silently - always provide clear feedback on what happened.
  </action>
  <verify>
- npm run compile succeeds
- Test with edge cases: no workspace, existing .planning, minimal input
  </verify>
  <done>
- Progress indicators shown during processing
- Clear error messages for all failure modes
- Graceful handling of incomplete user input with reasonable defaults
- Button to open created file works
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] /new-project command appears in registered commands
- [ ] Running /new-project in test workspace creates .planning/PROJECT.md
- [ ] Created PROJECT.md follows GSD template structure
- [ ] Error cases handled gracefully with clear messages
- [ ] Success message includes file reference and next step suggestion
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- /new-project command functional end-to-end
- PROJECT.md output matches GSD template format
</success_criteria>

<output>
After completion, create `.planning/phases/03-planning-commands/03-01-SUMMARY.md` following the summary template.
</output>
