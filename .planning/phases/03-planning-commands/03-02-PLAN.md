---
phase: 03-planning-commands
plan: 02
type: execute
---

<objective>
Implement the /create-roadmap command that creates ROADMAP.md and STATE.md from PROJECT.md.

Purpose: Enable users to break their project into phases, creating a structured roadmap that guides execution and a state file for tracking progress.

Output: Working /create-roadmap command that:
- Reads PROJECT.md to understand the project
- Uses LLM to suggest phases based on project requirements
- Allows user to adjust phases if needed
- Generates ROADMAP.md following GSD template
- Creates STATE.md for tracking current position
- Creates phase directories under .planning/phases/
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/03-planning-commands/03-01-PLAN.md

# Key source files:
@src/chat/commands/index.ts
@src/chat/commands/types.ts
@src/chat/context/projectContext.ts
@src/chat/generators/projectGenerator.ts

**Tech stack available:** ProjectConfig interface, CommandContext with stream/token/projectContext
**Established patterns:**
- Generator modules for file creation
- LLM parsing of user input
- Progress indicators during processing
- File references with stream.reference()

**GSD Templates to follow:**
@~/.claude/get-shit-done/templates/roadmap.md
@~/.claude/get-shit-done/templates/state.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create roadmap generator service module</name>
  <files>src/chat/generators/roadmapGenerator.ts, src/chat/generators/types.ts</files>
  <action>
Extend the generator types and create roadmap generator:

1. In types.ts, add:
   - PhaseConfig interface: { number: number, name: string, goal: string, dependsOn?: number, researchLikely: boolean, researchTopics?: string }
   - RoadmapConfig interface: { projectName: string, overview: string, phases: PhaseConfig[] }
   - StateConfig interface: { projectName: string, coreValue: string, currentPhase: number, totalPhases: number }

2. In roadmapGenerator.ts:
   - createRoadmapMd(config: RoadmapConfig): string - generates ROADMAP.md following GSD template
   - createStateMd(config: StateConfig): string - generates STATE.md following GSD template
   - createPhaseDirectories(workspaceUri: Uri, phases: PhaseConfig[]): Promise<void> - creates .planning/phases/XX-name/ directories
   - saveRoadmap(workspaceUri: Uri, roadmapConfig: RoadmapConfig, stateConfig: StateConfig): Promise<GeneratorResult>

Template structure for ROADMAP.md:
- # Roadmap: [Project Name]
- ## Overview
- ## Domain Expertise (None - SpecFlow doesn't use domain skills)
- ## Phases (checkbox list with descriptions)
- ## Phase Details (each phase with Goal, Depends on, Research flag, Plans: TBD)
- ## Progress (table with status tracking)

Template structure for STATE.md:
- # Project State
- ## Project Reference (link to PROJECT.md with core value)
- ## Current Position (Phase X of Y, not started)
- ## Performance Metrics (initialized to zero)
- ## Accumulated Context (empty sections)
- ## Session Continuity (last session date)

Avoid: Don't hardcode phase names - derive from PhaseConfig dynamically.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- types.ts exports PhaseConfig, RoadmapConfig, StateConfig interfaces
- roadmapGenerator.ts exports createRoadmapMd, createStateMd, createPhaseDirectories, saveRoadmap
- Generated markdown follows GSD templates
- Phase directories created with XX-kebab-name format
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /create-roadmap command handler</name>
  <files>src/chat/commands/createRoadmap.ts, src/chat/commands/index.ts</files>
  <action>
Create the /create-roadmap command handler:

1. In createRoadmap.ts, create handleCreateRoadmap handler that:
   - Checks if PROJECT.md exists - if not, prompt user to run /new-project first
   - Checks if ROADMAP.md already exists - if so, warn and offer options
   - Reads PROJECT.md content using vscode.workspace.fs
   - Uses LLM to analyze PROJECT.md and suggest phases

2. Phase suggestion flow:
   - Send PROJECT.md content to LLM with prompt asking for phase breakdown
   - Request: phase names, goals, dependencies, research flags
   - LLM should return JSON-parseable phase list
   - Target 3-8 phases based on project complexity (per GSD depth guidance)

3. Present phases to user:
   - Show suggested phases with stream.markdown()
   - Use numbered list format
   - Include research flags and brief goals

4. Generate files:
   - Create ROADMAP.md with roadmapGenerator
   - Create STATE.md with initial position
   - Create phase directories
   - Show success with file references
   - Suggest next step: /plan-phase 1

5. Update index.ts:
   - Import and register handleCreateRoadmap handler
   - Remove placeholder for create-roadmap command

Avoid: Don't prompt user for manual phase entry - use LLM to suggest, let user adjust via follow-up if needed.
  </action>
  <verify>
- npm run compile succeeds
- In test workspace with PROJECT.md, invoke /create-roadmap and verify ROADMAP.md, STATE.md, and phase directories created
  </verify>
  <done>
- handleCreateRoadmap registered in command registry
- Handler requires PROJECT.md to exist first
- LLM used to suggest phases from project requirements
- ROADMAP.md and STATE.md created following GSD templates
- Phase directories created under .planning/phases/
- Success message shows with file references and next step
  </done>
</task>

<task type="auto">
  <name>Task 3: Add LLM prompt engineering and error handling</name>
  <files>src/chat/commands/createRoadmap.ts</files>
  <action>
Enhance LLM interaction and error handling:

1. Craft effective LLM prompt for phase extraction:
   - Include PROJECT.md content
   - Ask for JSON output with specific schema: { phases: [{ name, goal, dependsOn, researchLikely, researchTopics }] }
   - Request 3-8 phases based on complexity
   - Ask for kebab-case names (e.g., "foundation", "core-features", "polish")

2. Parse LLM response robustly:
   - Try to extract JSON from response (may be wrapped in markdown code blocks)
   - Validate each phase has required fields
   - Fall back to simpler parsing if JSON fails

3. Add progress indicators:
   - stream.progress('Reading project details...')
   - stream.progress('Analyzing requirements and planning phases...')
   - stream.progress('Creating roadmap files...')

4. Error handling:
   - Missing PROJECT.md: Show button to run /new-project
   - LLM parsing failure: Show raw response and ask user to clarify
   - File write failure: Clear error message with details
   - Existing ROADMAP.md: Offer to view or replace

Avoid: Don't assume LLM will always return perfect JSON - have fallback parsing strategies.
  </action>
  <verify>
- npm run compile succeeds
- Test edge cases: no PROJECT.md, existing ROADMAP.md, malformed LLM response
  </verify>
  <done>
- LLM prompt engineered for reliable JSON phase output
- Robust parsing with fallbacks for non-JSON responses
- Progress indicators shown during all async operations
- Clear error messages for all failure modes
- Existing file detection with appropriate user choices
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] /create-roadmap command appears in registered commands
- [ ] Running /create-roadmap in workspace with PROJECT.md creates ROADMAP.md and STATE.md
- [ ] Phase directories created under .planning/phases/
- [ ] Created files follow GSD template structure
- [ ] Error handling works for missing PROJECT.md
- [ ] Success message includes file references and next step suggestion
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- /create-roadmap command functional end-to-end
- ROADMAP.md and STATE.md output matches GSD template format
- Phase directories created with correct naming convention
</success_criteria>

<output>
After completion, create `.planning/phases/03-planning-commands/03-02-SUMMARY.md` following the summary template.
</output>
