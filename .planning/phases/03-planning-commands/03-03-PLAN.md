---
phase: 03-planning-commands
plan: 03
type: execute
---

<objective>
Implement the /plan-phase command that creates detailed PLAN.md files for a specific phase.

Purpose: Enable users to generate executable phase plans with specific tasks, verification criteria, and success conditions following GSD conventions.

Output: Working /plan-phase command that:
- Accepts phase number argument (e.g., /plan-phase 1)
- Reads PROJECT.md, ROADMAP.md, and STATE.md for context
- Uses LLM to generate tasks based on phase goal
- Creates PLAN.md in the phase directory
- Follows GSD plan template with XML task structure
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan context:
@.planning/phases/03-planning-commands/03-01-PLAN.md
@.planning/phases/03-planning-commands/03-02-PLAN.md

# Key source files:
@src/chat/commands/index.ts
@src/chat/commands/types.ts
@src/chat/context/projectContext.ts
@src/chat/generators/roadmapGenerator.ts

**Tech stack available:** RoadmapConfig, PhaseConfig interfaces, CommandContext
**Established patterns:**
- Generator modules for file creation
- LLM parsing with JSON schema prompts
- Progress indicators during processing
- File references with stream.reference()

**GSD Templates to follow:**
@~/.claude/get-shit-done/templates/phase-prompt.md
@~/.claude/get-shit-done/references/plan-format.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plan generator service module</name>
  <files>src/chat/generators/planGenerator.ts, src/chat/generators/types.ts</files>
  <action>
Extend generator types and create plan generator:

1. In types.ts, add:
   - TaskConfig interface: { name: string, type: 'auto' | 'checkpoint:human-verify' | 'checkpoint:decision', files?: string[], action: string, verify: string, done: string }
   - CheckpointVerifyConfig: { whatBuilt: string, howToVerify: string[], resumeSignal: string }
   - CheckpointDecisionConfig: { decision: string, context: string, options: { id: string, name: string, pros: string, cons: string }[], resumeSignal: string }
   - PlanConfig interface: { phase: string, planNumber: number, objective: string, purpose: string, output: string, tasks: TaskConfig[], verification: string[], successCriteria: string[] }

2. In planGenerator.ts:
   - createPlanMd(config: PlanConfig): string - generates PLAN.md following GSD template
   - formatTask(task: TaskConfig): string - formats a single task in XML structure
   - savePlan(workspaceUri: Uri, phaseDir: string, config: PlanConfig): Promise<GeneratorResult>

Template structure for PLAN.md:
- YAML frontmatter: phase, plan, type: execute
- <objective> section with purpose and output
- <execution_context> referencing GSD workflows
- <context> with @file references
- <tasks> with XML-formatted task elements
- <verification> checklist
- <success_criteria> list
- <output> specifying SUMMARY.md creation

Task XML format:
```xml
<task type="auto">
  <name>Task N: [Name]</name>
  <files>[paths]</files>
  <action>[what to do]</action>
  <verify>[how to verify]</verify>
  <done>[acceptance criteria]</done>
</task>
```

Avoid: Don't use generic task descriptions - each task should have specific files, actions, and verification.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- types.ts exports TaskConfig, CheckpointVerifyConfig, CheckpointDecisionConfig, PlanConfig
- planGenerator.ts exports createPlanMd, formatTask, savePlan
- Generated PLAN.md follows GSD template with XML task structure
- Task formatting includes all required fields
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /plan-phase command handler</name>
  <files>src/chat/commands/planPhase.ts, src/chat/commands/index.ts</files>
  <action>
Create the /plan-phase command handler:

1. In planPhase.ts, create handlePlanPhase handler that:
   - Parses phase number from request.prompt (e.g., "1" from "/plan-phase 1")
   - Validates phase exists in ROADMAP.md
   - Checks if PLAN.md already exists for this phase
   - Reads PROJECT.md, ROADMAP.md, STATE.md for context

2. Context gathering:
   - Extract phase goal and dependencies from ROADMAP.md
   - Get project requirements and constraints from PROJECT.md
   - Check what phases are complete from STATE.md

3. LLM task generation:
   - Send full context to LLM
   - Ask for 2-3 concrete tasks with specific files, actions, verification
   - Request JSON output with TaskConfig schema
   - Include guidance: tasks should be auto type unless visual verification or decision needed

4. Generate PLAN.md:
   - Use planGenerator to create properly formatted plan
   - Include @context references to PROJECT.md, ROADMAP.md, STATE.md
   - Save to .planning/phases/XX-name/XX-01-PLAN.md

5. Update index.ts:
   - Import and register handlePlanPhase handler
   - Remove placeholder for plan-phase command

6. Success output:
   - Show created plan with file reference
   - Suggest next step: /execute-plan (coming in Phase 4)

Avoid: Don't generate more than 3 tasks per plan - follow GSD scope guidance.
  </action>
  <verify>
- npm run compile succeeds
- In test workspace with ROADMAP.md, invoke /plan-phase 1 and verify PLAN.md created in phase directory
  </verify>
  <done>
- handlePlanPhase registered in command registry
- Handler parses phase number from prompt
- Handler validates phase exists in ROADMAP.md
- LLM generates 2-3 specific tasks with all required fields
- PLAN.md created following GSD template with XML task structure
- Success message shows with file reference
  </done>
</task>

<task type="auto">
  <name>Task 3: Add argument parsing, validation, and error handling</name>
  <files>src/chat/commands/planPhase.ts</files>
  <action>
Enhance command with robust argument handling and errors:

1. Argument parsing:
   - If no argument: suggest next unplanned phase from ROADMAP.md
   - If invalid argument (not a number): show usage help
   - Support decimal phases (e.g., "1.5" for inserted urgent work)

2. Validation:
   - Check ROADMAP.md exists - if not, prompt /create-roadmap first
   - Check phase number exists in roadmap
   - Check dependent phases are complete (from STATE.md)
   - Warn if planning out of order (non-blocking)

3. LLM prompt engineering:
   - Include explicit task schema in prompt
   - Request specific file paths, not generic descriptions
   - Ask for verify commands that can be run (npm test, curl, etc.)
   - Request done criteria that are measurable

4. Progress indicators:
   - stream.progress('Reading project context...')
   - stream.progress('Analyzing phase requirements...')
   - stream.progress('Generating execution plan...')

5. Error handling:
   - Missing roadmap: Show button to run /create-roadmap
   - Invalid phase: List valid phases from roadmap
   - Existing plan: Offer to view or regenerate
   - LLM parsing failure: Show error and retry option

Avoid: Don't block on dependent phases - warn but allow planning ahead.
  </action>
  <verify>
- npm run compile succeeds
- Test edge cases: no argument, invalid phase, missing roadmap, existing plan
  </verify>
  <done>
- Phase number parsing handles missing, invalid, and decimal inputs
- Validation checks roadmap and phase existence
- Dependency warnings shown but don't block
- Progress indicators for all async operations
- Clear error messages with actionable suggestions
- Existing plan detection with user choices
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] /plan-phase command appears in registered commands
- [ ] Running /plan-phase 1 in workspace with ROADMAP.md creates phase plan
- [ ] Created PLAN.md follows GSD template with XML task structure
- [ ] Tasks have specific files, actions, and verification criteria
- [ ] Error handling works for missing roadmap, invalid phase
- [ ] Success message includes file reference
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- /plan-phase command functional end-to-end
- PLAN.md output matches GSD template format with XML task structure
- Generated tasks are specific and actionable (not vague)
- Phase 3: Planning Commands complete after this plan
</success_criteria>

<output>
After completion, create `.planning/phases/03-planning-commands/03-03-SUMMARY.md` following the summary template.

Note: This is the final plan in Phase 3. After summary creation, update STATE.md to mark Phase 3 complete.
</output>
