---
phase: 06-security-review
plan: 03
type: execute
---

<objective>
Implement safe auto-fix transforms using jscodeshift for high-confidence security issues.

Purpose: Enable automatic remediation of clear-cut vulnerabilities without breaking code.
Output: Transform functions for XSS and crypto fixes that preserve code formatting.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-review/06-RESEARCH.md
@.planning/phases/06-security-review/06-CONTEXT.md
@src/security/types.ts
@src/security/scanner.ts

**From research:**
- jscodeshift for AST-based transforms (preserves formatting via recast)
- DOMPurify for XSS sanitization
- crypto.randomBytes for secure random
- crypto.timingSafeEqual for timing attack prevention
- Only auto-fix HIGH confidence issues

**Key insight:**
Never use regex for code modification - AST transforms handle edge cases. Only fix when transformation is semantically equivalent or strictly safer.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create jscodeshift transform infrastructure</name>
  <files>src/security/fixes/index.ts, package.json</files>
  <action>
1. **Install jscodeshift:**
   ```bash
   npm install jscodeshift
   npm install -D @types/jscodeshift
   ```

2. **Create transform infrastructure in src/security/fixes/index.ts:**

```typescript
import jscodeshift, { API, FileInfo, Transform } from 'jscodeshift';
import * as vscode from 'vscode';

/**
 * Result of applying a fix
 */
export interface FixResult {
  file: string;
  applied: boolean;
  description: string;
  originalCode?: string;
  fixedCode?: string;
  error?: string;
}

/**
 * Apply a jscodeshift transform to a file
 */
export async function applyTransform(
  fileUri: vscode.Uri,
  transform: Transform,
  description: string
): Promise<FixResult> {
  try {
    // Read file content
    const content = await vscode.workspace.fs.readFile(fileUri);
    const source = Buffer.from(content).toString('utf-8');

    // Create jscodeshift API
    const j = jscodeshift.withParser('tsx'); // Support both TS and TSX

    // Create file info
    const fileInfo: FileInfo = {
      path: fileUri.fsPath,
      source
    };

    // Create API object
    const api: API = {
      jscodeshift: j,
      j,
      stats: () => {},
      report: () => {}
    };

    // Run transform
    const result = transform(fileInfo, api, {});

    // If no changes, return not applied
    if (!result || result === source) {
      return {
        file: fileUri.fsPath,
        applied: false,
        description,
        error: 'No changes needed'
      };
    }

    // Write back
    await vscode.workspace.fs.writeFile(fileUri, Buffer.from(result, 'utf-8'));

    return {
      file: fileUri.fsPath,
      applied: true,
      description,
      originalCode: source.slice(0, 200),
      fixedCode: result.slice(0, 200)
    };
  } catch (err) {
    return {
      file: fileUri.fsPath,
      applied: false,
      description,
      error: err instanceof Error ? err.message : String(err)
    };
  }
}

/**
 * Apply multiple fixes to a file
 */
export async function applyFixes(
  fileUri: vscode.Uri,
  transforms: Array<{ transform: Transform; description: string }>
): Promise<FixResult[]> {
  const results: FixResult[] = [];

  for (const { transform, description } of transforms) {
    const result = await applyTransform(fileUri, transform, description);
    results.push(result);

    // If a transform failed (not just "no changes"), stop
    if (!result.applied && result.error && result.error !== 'No changes needed') {
      break;
    }
  }

  return results;
}
```

3. **Export from security/index.ts**
  </action>
  <verify>npx tsc --noEmit compiles without errors</verify>
  <done>Transform infrastructure created with applyTransform and applyFixes functions</done>
</task>

<task type="auto">
  <name>Task 2: Implement XSS fix transforms</name>
  <files>src/security/fixes/xss.ts</files>
  <action>
Create XSS remediation transforms:

1. **innerHTMLToDOMPurify transform:**
   - Find: `element.innerHTML = unsafeValue`
   - Replace with: `element.innerHTML = DOMPurify.sanitize(unsafeValue)`
   - Skip if already wrapped with DOMPurify
   - Add import if not present: `import DOMPurify from 'dompurify'`

```typescript
import { Transform } from 'jscodeshift';

export const innerHTMLToDOMPurify: Transform = (file, api) => {
  const j = api.jscodeshift;
  const root = j(file.source);
  let modified = false;

  // Find innerHTML assignments
  root.find(j.AssignmentExpression, {
    left: {
      type: 'MemberExpression',
      property: { name: 'innerHTML' }
    }
  })
  .forEach(path => {
    const right = path.node.right;

    // Skip if already wrapped with DOMPurify
    if (right.type === 'CallExpression') {
      const callee = right.callee;
      if (callee.type === 'MemberExpression' &&
          callee.object.type === 'Identifier' &&
          callee.object.name === 'DOMPurify') {
        return;
      }
    }

    // Wrap with DOMPurify.sanitize()
    path.node.right = j.callExpression(
      j.memberExpression(
        j.identifier('DOMPurify'),
        j.identifier('sanitize')
      ),
      [right]
    );
    modified = true;
  });

  // Add import if we made changes
  if (modified) {
    const imports = root.find(j.ImportDeclaration);
    const hasDOMPurify = imports.some(
      p => p.node.source.value === 'dompurify'
    );

    if (!hasDOMPurify) {
      const newImport = j.importDeclaration(
        [j.importDefaultSpecifier(j.identifier('DOMPurify'))],
        j.literal('dompurify')
      );

      // Insert after last import or at top
      const lastImport = imports.at(-1);
      if (lastImport.length) {
        lastImport.insertAfter(newImport);
      } else {
        root.find(j.Program).get('body', 0).insertBefore(newImport);
      }
    }
  }

  return modified ? root.toSource() : null;
};
```

2. **innerHTMLToTextContent transform (simpler cases):**
   - For cases where HTML is NOT intended
   - Find: `element.innerHTML = simpleString` (literal or simple variable)
   - Replace with: `element.textContent = simpleString`
   - Only apply when right-hand side is Identifier or StringLiteral (safe patterns)

```typescript
export const innerHTMLToTextContent: Transform = (file, api) => {
  const j = api.jscodeshift;
  const root = j(file.source);
  let modified = false;

  root.find(j.AssignmentExpression, {
    left: {
      type: 'MemberExpression',
      property: { name: 'innerHTML' }
    }
  })
  .forEach(path => {
    const right = path.node.right;

    // Only convert simple cases (literals, simple variables)
    // NOT template literals, concatenation, or function calls
    if (right.type === 'StringLiteral' ||
        right.type === 'Literal' ||
        (right.type === 'Identifier' && !right.name.includes('html'))) {

      // Change innerHTML to textContent
      if (path.node.left.type === 'MemberExpression') {
        path.node.left.property = j.identifier('textContent');
        modified = true;
      }
    }
  });

  return modified ? root.toSource() : null;
};
```

3. **Export transforms with metadata:**
```typescript
export const XSS_TRANSFORMS = {
  'no-unsanitized/property': {
    transform: innerHTMLToDOMPurify,
    description: 'Wrap innerHTML with DOMPurify.sanitize()',
    confidence: 'medium' as const,
    requiresPackage: 'dompurify'
  }
};
```
  </action>
  <verify>Create test file with innerHTML = userInput, apply transform, verify DOMPurify added</verify>
  <done>XSS transforms convert innerHTML to safe alternatives, add DOMPurify import</done>
</task>

<task type="auto">
  <name>Task 3: Implement crypto fix transforms</name>
  <files>src/security/fixes/crypto.ts, src/security/fixes/index.ts</files>
  <action>
Create cryptography remediation transforms:

1. **mathRandomToCrypto transform:**
   - Find: `Math.random()`
   - Replace with: `crypto.randomBytes(4).readUInt32LE() / 0xffffffff`
   - Add import: `import { randomBytes } from 'crypto'`
   - Note: This is for cases where secure randomness is needed (tokens, IDs)

```typescript
export const mathRandomToCrypto: Transform = (file, api) => {
  const j = api.jscodeshift;
  const root = j(file.source);
  let modified = false;

  // Find Math.random() calls
  root.find(j.CallExpression, {
    callee: {
      type: 'MemberExpression',
      object: { name: 'Math' },
      property: { name: 'random' }
    }
  })
  .forEach(path => {
    // Replace with crypto.randomBytes pattern
    // crypto.randomBytes(4).readUInt32LE() / 0xffffffff
    path.replace(
      j.binaryExpression(
        '/',
        j.callExpression(
          j.memberExpression(
            j.callExpression(
              j.memberExpression(
                j.identifier('crypto'),
                j.identifier('randomBytes')
              ),
              [j.literal(4)]
            ),
            j.identifier('readUInt32LE')
          ),
          []
        ),
        j.literal(0xffffffff)
      )
    );
    modified = true;
  });

  // Add import if modified
  if (modified) {
    addCryptoImport(j, root);
  }

  return modified ? root.toSource() : null;
};

function addCryptoImport(j: any, root: any) {
  const imports = root.find(j.ImportDeclaration);
  const hasCrypto = imports.some(
    (p: any) => p.node.source.value === 'crypto'
  );

  if (!hasCrypto) {
    const newImport = j.importDeclaration(
      [j.importSpecifier(j.identifier('randomBytes'))],
      j.literal('crypto')
    );

    const lastImport = imports.at(-1);
    if (lastImport.length) {
      lastImport.insertAfter(newImport);
    } else {
      root.find(j.Program).get('body', 0).insertBefore(newImport);
    }
  }
}
```

2. **timingSafeEqual transform:**
   - Find: `a === b` or `a == b` where variables suggest secret comparison
   - Replace with: `crypto.timingSafeEqual(Buffer.from(a), Buffer.from(b))`
   - Only for identifiers containing: secret, token, key, hash, password, signature
   - This is HIGH confidence when variable names match

```typescript
const SECRET_PATTERNS = /secret|token|key|hash|password|signature|apikey/i;

export const equalToTimingSafe: Transform = (file, api) => {
  const j = api.jscodeshift;
  const root = j(file.source);
  let modified = false;

  root.find(j.BinaryExpression, {
    operator: (op: string) => op === '===' || op === '=='
  })
  .forEach(path => {
    const { left, right } = path.node;

    // Check if either operand is a secret-like identifier
    const leftName = left.type === 'Identifier' ? left.name : '';
    const rightName = right.type === 'Identifier' ? right.name : '';

    if (SECRET_PATTERNS.test(leftName) || SECRET_PATTERNS.test(rightName)) {
      // Replace with timingSafeEqual
      path.replace(
        j.callExpression(
          j.memberExpression(
            j.identifier('crypto'),
            j.identifier('timingSafeEqual')
          ),
          [
            j.callExpression(
              j.memberExpression(j.identifier('Buffer'), j.identifier('from')),
              [left]
            ),
            j.callExpression(
              j.memberExpression(j.identifier('Buffer'), j.identifier('from')),
              [right]
            )
          ]
        )
      );
      modified = true;
    }
  });

  if (modified) {
    addCryptoTimingSafeImport(j, root);
  }

  return modified ? root.toSource() : null;
};
```

3. **Update fixes/index.ts:**
   - Export all transforms
   - Create TRANSFORM_REGISTRY mapping ruleId to transform:
   ```typescript
   export const TRANSFORM_REGISTRY: Record<string, {
     transform: Transform;
     description: string;
     confidence: FixConfidence;
     requiresPackage?: string;
   }> = {
     'no-unsanitized/property': XSS_TRANSFORMS['no-unsanitized/property'],
     'security/detect-pseudoRandomBytes': {
       transform: mathRandomToCrypto,
       description: 'Replace Math.random() with crypto.randomBytes()',
       confidence: 'high'
     },
     'security/detect-possible-timing-attacks': {
       transform: equalToTimingSafe,
       description: 'Replace === with crypto.timingSafeEqual()',
       confidence: 'high'
     }
   };
   ```

4. **Create getFixForIssue function:**
   ```typescript
   export function getFixForIssue(issue: SecurityIssue): {
     transform: Transform;
     description: string;
   } | undefined {
     if (!issue.ruleId || !issue.fixable) return undefined;
     return TRANSFORM_REGISTRY[issue.ruleId];
   }
   ```
  </action>
  <verify>Create test with Math.random(), apply transform, verify crypto import added</verify>
  <done>Crypto transforms replace insecure patterns, registry maps rules to transforms</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] jscodeshift installed and working
- [ ] innerHTML → DOMPurify transform works
- [ ] Math.random → crypto transform works
- [ ] Timing attack transform works for secret-like variables
- [ ] TRANSFORM_REGISTRY maps rules to transforms
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Transforms preserve code formatting
- Only high-confidence patterns auto-fixed
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-review/06-03-SUMMARY.md` following the summary template.
</output>
