---
phase: 06-security-review
plan: 04
type: execute
---

<objective>
Create the /security-check command with two-phase UX: summary â†’ details â†’ fix options.

Purpose: Provide users with actionable security analysis and safe remediation options.
Output: Working /security-check command that scans code, shows findings, and offers fixes.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-security-review/06-RESEARCH.md
@.planning/phases/06-security-review/06-CONTEXT.md
@src/security/types.ts
@src/security/scanner.ts
@src/security/advisories.ts
@src/security/fixes/index.ts
@src/chat/commands/verifyWork.ts
@src/chat/commands/index.ts
@src/chat/hopperParticipant.ts

**From context:**
- Summary first, then drill-down
- Auto-fix safe issues, interactive for judgment calls
- Severity levels: critical/high/medium/low
- OWASP categories for organization

**Patterns established:**
- Commands in src/chat/commands/
- stream.markdown() for output
- stream.button() for actions
- vscode.window.showQuickPick for interactive choices
- Register in commands/index.ts and hopperParticipant.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /security-check command handler</name>
  <files>src/chat/commands/securityCheck.ts</files>
  <action>
Create main security check command:

```typescript
import * as vscode from 'vscode';
import { CommandContext, IHopperResult } from './types';
import {
  SecurityIssue,
  DependencyIssue,
  getLatestAdvisories,
  matchAdvisoriesToDependencies,
  scanFiles,
  readPackageJson
} from '../../security';

/**
 * Handle /security-check command
 *
 * Scans user's codebase for security vulnerabilities.
 * Two-phase UX: summary â†’ category details â†’ fix options
 */
export async function handleSecurityCheck(ctx: CommandContext): Promise<IHopperResult> {
  const { stream, token, extensionContext } = ctx;

  // Get workspace root
  const workspaceFolders = vscode.workspace.workspaceFolders;
  if (!workspaceFolders || workspaceFolders.length === 0) {
    stream.markdown('## No Workspace Open\n\n');
    stream.markdown('Open a folder to scan for security issues.\n');
    return { metadata: { lastCommand: 'security-check' } };
  }

  const workspaceUri = workspaceFolders[0].uri;

  stream.markdown('## Security Check\n\n');
  stream.markdown('Scanning your codebase for vulnerabilities...\n\n');

  // Phase 1: Update threat intelligence
  stream.progress('Updating threat intelligence...');
  const { advisories, fromCache, cacheAge } = await getLatestAdvisories(extensionContext);

  const cacheStatus = fromCache
    ? `(cached ${Math.round(cacheAge / 1000 / 60)} min ago)`
    : '(fresh)';
  stream.markdown(`**Threat intelligence:** ${advisories.length} advisories loaded ${cacheStatus}\n\n`);

  // Phase 2: Check dependencies
  stream.progress('Checking dependencies...');
  const packageJson = await readPackageJson(workspaceUri);
  const dependencyIssues: DependencyIssue[] = [];

  if (packageJson) {
    const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
    const matched = matchAdvisoriesToDependencies(advisories, deps);
    dependencyIssues.push(...matched);
  }

  // Phase 3: Scan code
  stream.progress('Scanning code for vulnerabilities...');
  const scanPatterns = [
    vscode.Uri.joinPath(workspaceUri, 'src/**/*.ts').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'src/**/*.tsx').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'src/**/*.js').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'src/**/*.jsx').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'lib/**/*.ts').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'app/**/*.ts').fsPath,
    vscode.Uri.joinPath(workspaceUri, 'app/**/*.tsx').fsPath,
  ];

  const { issues: codeIssues, filesScanned, duration } = await scanFiles(scanPatterns);

  // Combine all issues
  const allIssues = [...codeIssues, ...dependencyIssues];

  // Show summary
  await showScanSummary(stream, allIssues, filesScanned, duration, dependencyIssues.length);

  if (allIssues.length === 0) {
    stream.markdown('### No Issues Found\n\n');
    stream.markdown('Your code passed all security checks. Great job!\n\n');
    return {
      metadata: {
        lastCommand: 'security-check',
        issuesFound: 0
      }
    };
  }

  // Store issues in globalState for fix commands
  await extensionContext.globalState.update('hopper.security.lastScanIssues', allIssues);

  // Show category breakdown and fix options
  await showCategoryBreakdown(stream, allIssues);
  await showFixOptions(stream, allIssues);

  return {
    metadata: {
      lastCommand: 'security-check',
      issuesFound: allIssues.length,
      critical: allIssues.filter(i => i.severity === 'critical').length,
      high: allIssues.filter(i => i.severity === 'high').length
    }
  };
}
```

Implement helper functions:

```typescript
async function showScanSummary(
  stream: vscode.ChatResponseStream,
  issues: SecurityIssue[],
  filesScanned: number,
  duration: number,
  depIssues: number
): Promise<void> {
  const critical = issues.filter(i => i.severity === 'critical').length;
  const high = issues.filter(i => i.severity === 'high').length;
  const medium = issues.filter(i => i.severity === 'medium').length;
  const low = issues.filter(i => i.severity === 'low').length;

  stream.markdown('### Scan Summary\n\n');
  stream.markdown(`| Metric | Value |\n`);
  stream.markdown(`|--------|-------|\n`);
  stream.markdown(`| Files scanned | ${filesScanned} |\n`);
  stream.markdown(`| Duration | ${duration}ms |\n`);
  stream.markdown(`| Dependency issues | ${depIssues} |\n`);
  stream.markdown(`| Code issues | ${issues.length - depIssues} |\n\n`);

  stream.markdown('### Issues by Severity\n\n');
  stream.markdown(`| Severity | Count |\n`);
  stream.markdown(`|----------|-------|\n`);
  if (critical > 0) stream.markdown(`| ðŸ”´ Critical | ${critical} |\n`);
  if (high > 0) stream.markdown(`| ðŸŸ  High | ${high} |\n`);
  if (medium > 0) stream.markdown(`| ðŸŸ¡ Medium | ${medium} |\n`);
  if (low > 0) stream.markdown(`| ðŸŸ¢ Low | ${low} |\n`);
  stream.markdown('\n');
}
```
  </action>
  <verify>Command can be invoked, shows progress, returns scan summary</verify>
  <done>Security check command scans code and dependencies, shows summary</done>
</task>

<task type="auto">
  <name>Task 2: Implement two-phase UX with category breakdown and fixes</name>
  <files>src/chat/commands/securityCheck.ts</files>
  <action>
Add category breakdown and interactive fix flow:

```typescript
async function showCategoryBreakdown(
  stream: vscode.ChatResponseStream,
  issues: SecurityIssue[]
): Promise<void> {
  // Group by OWASP category
  const byCategory = new Map<string, SecurityIssue[]>();

  for (const issue of issues) {
    const category = issue.owasp || 'Uncategorized';
    const existing = byCategory.get(category) || [];
    existing.push(issue);
    byCategory.set(category, existing);
  }

  stream.markdown('### Issues by OWASP Category\n\n');

  for (const [category, categoryIssues] of byCategory) {
    const severityIcon = getSeverityIcon(getMaxSeverity(categoryIssues));
    stream.markdown(`#### ${severityIcon} ${formatOWASPCategory(category)}\n\n`);

    for (const issue of categoryIssues.slice(0, 5)) {
      const icon = getSeverityIcon(issue.severity);
      const location = issue.file
        ? `\`${issue.file}:${issue.line}\``
        : issue.type === 'dependency'
          ? `\`${(issue as DependencyIssue).package}\``
          : '';

      stream.markdown(`- ${icon} **${issue.severity.toUpperCase()}**: ${issue.message}\n`);
      if (location) stream.markdown(`  - Location: ${location}\n`);
      if (issue.suggestedFix) stream.markdown(`  - Fix: ${issue.suggestedFix}\n`);
    }

    if (categoryIssues.length > 5) {
      stream.markdown(`  - *...and ${categoryIssues.length - 5} more*\n`);
    }
    stream.markdown('\n');
  }
}

function getSeverityIcon(severity: string): string {
  switch (severity) {
    case 'critical': return 'ðŸ”´';
    case 'high': return 'ðŸŸ ';
    case 'medium': return 'ðŸŸ¡';
    case 'low': return 'ðŸŸ¢';
    default: return 'âšª';
  }
}

function getMaxSeverity(issues: SecurityIssue[]): string {
  const order = ['critical', 'high', 'medium', 'low', 'info'];
  for (const severity of order) {
    if (issues.some(i => i.severity === severity)) {
      return severity;
    }
  }
  return 'info';
}

function formatOWASPCategory(category: string): string {
  // A05:2025-Injection â†’ A05: Injection
  const match = category.match(/^(A\d+):(\d+)-(.+)$/);
  if (match) {
    return `${match[1]}: ${match[3].replace(/-/g, ' ')}`;
  }
  return category;
}
```

```typescript
async function showFixOptions(
  stream: vscode.ChatResponseStream,
  issues: SecurityIssue[]
): Promise<void> {
  const fixable = issues.filter(i => i.fixable);
  const autoFixable = fixable.filter(i => i.fixConfidence === 'high');
  const needsReview = fixable.filter(i => i.fixConfidence !== 'high');

  stream.markdown('---\n\n');
  stream.markdown('### Remediation Options\n\n');

  if (autoFixable.length > 0) {
    stream.markdown(`**Auto-fixable:** ${autoFixable.length} issue(s) can be safely fixed automatically.\n\n`);
    stream.button({
      command: 'hopper.securityAutoFix',
      title: `Auto-fix ${autoFixable.length} Safe Issues`
    });
    stream.markdown('\n\n');
  }

  if (needsReview.length > 0) {
    stream.markdown(`**Needs review:** ${needsReview.length} issue(s) require human judgment.\n\n`);
    stream.button({
      command: 'hopper.securityInteractiveFix',
      title: `Review ${needsReview.length} Issues`
    });
    stream.markdown('\n\n');
  }

  const unfixable = issues.filter(i => !i.fixable);
  if (unfixable.length > 0) {
    stream.markdown(`**Manual fixes needed:** ${unfixable.length} issue(s) require manual remediation.\n`);
    stream.markdown('These issues are flagged but cannot be auto-fixed (e.g., architectural changes needed).\n\n');
  }

  // Dependency updates
  const depIssues = issues.filter(i => i.type === 'dependency') as DependencyIssue[];
  const updatable = depIssues.filter(i => i.patchedVersions);

  if (updatable.length > 0) {
    stream.markdown(`**Dependency updates:** ${updatable.length} vulnerable package(s) have patches available.\n\n`);

    const updateCommands = updatable.map(i =>
      `npm install ${i.package}@${i.patchedVersions}`
    ).join(' && ');

    stream.markdown('```bash\n' + updateCommands + '\n```\n\n');
  }
}
```
  </action>
  <verify>Command shows OWASP categories, severity breakdown, and fix buttons</verify>
  <done>Two-phase UX complete with summary, category breakdown, and fix options</done>
</task>

<task type="auto">
  <name>Task 3: Register command and implement fix handlers</name>
  <files>src/chat/commands/index.ts, src/chat/hopperParticipant.ts, src/extension.ts</files>
  <action>
1. **Register in commands/index.ts:**
   ```typescript
   import { handleSecurityCheck } from './securityCheck';

   // In COMMANDS object:
   'security-check': {
     handler: handleSecurityCheck,
     description: 'Scan codebase for security vulnerabilities',
     requiresLicense: true,
     phase: 2 // Security features are Pro
   },
   ```

2. **Add slash command in hopperParticipant.ts:**
   In the slashCommands array:
   ```typescript
   {
     name: 'security-check',
     description: 'Scan for security vulnerabilities'
   },
   ```

3. **Register fix commands in extension.ts:**
   ```typescript
   // Auto-fix command
   context.subscriptions.push(
     vscode.commands.registerCommand('hopper.securityAutoFix', async () => {
       const issues = context.globalState.get<SecurityIssue[]>('hopper.security.lastScanIssues');
       if (!issues) {
         vscode.window.showWarningMessage('Run /security-check first');
         return;
       }

       const autoFixable = issues.filter(i => i.fixable && i.fixConfidence === 'high');

       // Apply fixes
       let fixed = 0;
       for (const issue of autoFixable) {
         if (issue.file && issue.ruleId) {
           const fileUri = vscode.Uri.file(issue.file);
           const fixInfo = getFixForIssue(issue);
           if (fixInfo) {
             const result = await applyTransform(fileUri, fixInfo.transform, fixInfo.description);
             if (result.applied) fixed++;
           }
         }
       }

       vscode.window.showInformationMessage(`Fixed ${fixed} of ${autoFixable.length} issues`);
     })
   );

   // Interactive fix command
   context.subscriptions.push(
     vscode.commands.registerCommand('hopper.securityInteractiveFix', async () => {
       const issues = context.globalState.get<SecurityIssue[]>('hopper.security.lastScanIssues');
       if (!issues) {
         vscode.window.showWarningMessage('Run /security-check first');
         return;
       }

       const needsReview = issues.filter(i => i.fixable && i.fixConfidence !== 'high');

       for (const issue of needsReview) {
         const choice = await vscode.window.showQuickPick(
           [
             { label: 'Apply Fix', value: 'fix' },
             { label: 'Skip', value: 'skip' },
             { label: 'Stop Reviewing', value: 'stop' }
           ],
           {
             title: `${issue.severity.toUpperCase()}: ${issue.message}`,
             placeHolder: issue.file ? `${issue.file}:${issue.line}` : issue.message
           }
         );

         if (!choice || choice.value === 'stop') break;

         if (choice.value === 'fix' && issue.file && issue.ruleId) {
           const fileUri = vscode.Uri.file(issue.file);
           const fixInfo = getFixForIssue(issue);
           if (fixInfo) {
             const result = await applyTransform(fileUri, fixInfo.transform, fixInfo.description);
             if (result.applied) {
               vscode.window.showInformationMessage(`Fixed: ${fixInfo.description}`);
             }
           }
         }
       }
     })
   );
   ```

4. **Add imports to extension.ts:**
   ```typescript
   import { SecurityIssue, getFixForIssue, applyTransform } from './security';
   ```
  </action>
  <verify>Command appears in chat, buttons trigger fix handlers</verify>
  <done>Command registered, fix handlers implemented, full integration complete</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete /security-check command with scanning, categorization, and fix options</what-built>
  <how-to-verify>
    1. Open a workspace with JavaScript/TypeScript code
    2. In chat, type: @hopper /security-check
    3. Verify scan runs and shows:
       - Threat intelligence status
       - Files scanned count
       - Issues by severity table
       - OWASP category breakdown
    4. If issues found, verify fix buttons appear
    5. Test auto-fix button on a safe issue (if any)
    6. Verify code is modified correctly
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] /security-check command registered and accessible
- [ ] Scan runs and shows summary
- [ ] OWASP categories displayed correctly
- [ ] Fix buttons appear for fixable issues
- [ ] Auto-fix applies transforms correctly
- [ ] Interactive fix flow works
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- User approved checkpoint
- No TypeScript errors
- Full security scanning workflow operational
</success_criteria>

<output>
After completion, create `.planning/phases/06-security-review/06-04-SUMMARY.md` following the summary template.
</output>
