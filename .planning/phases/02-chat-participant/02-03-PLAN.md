---
phase: 02-chat-participant
plan: 03
type: execute
---

<objective>
Implement context injection for SpecFlow commands using workspace analysis.

Purpose: Create infrastructure to automatically inject project context (.planning files) into command prompts, preparing for Phase 3 commands that need project state awareness.
Output: Context provider that reads and formats .planning files for inclusion in LLM prompts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase:
@.planning/phases/02-chat-participant/02-01-SUMMARY.md
@.planning/phases/02-chat-participant/02-02-SUMMARY.md

# Key source files:
@src/chat/specflowParticipant.ts
@src/chat/commands/index.ts
@src/chat/commands/types.ts

**Tech stack available:**
- VSCode Workspace API (fs operations)
- TypeScript ^5.6.3

**Established patterns:**
- CommandContext passed to handlers
- Stream responses via stream.markdown()

**Discovery note:**
The Chat Variables API (registerChatVariableResolver) is still proposed/unstable.
Instead, we'll inject context directly into prompts using VSCode workspace file reading.
This approach is more reliable and works with all VSCode versions.

**Key Patterns from Research:**
- Use `stream.reference(uri)` for clickable file links that open in editor (Don't Hand-Roll section)
- Use `stream.filetree(tree, base)` for interactive file tree previews
- Handle token limits: Implement basic history truncation, ~2000 chars per file (Pitfall 4)
- Access conversation history via `context.history` for multi-turn awareness (Pattern 3)
- Use `stream.progress()` while loading context files
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create context provider module</name>
  <files>src/chat/context/projectContext.ts</files>
  <action>
Create context provider that reads .planning files:

1. Define ProjectContext interface:
   - hasPlanning: boolean
   - workspaceUri?: vscode.Uri (for stream.reference() calls)
   - planningUri?: vscode.Uri (for file tree display)
   - projectMd?: string (PROJECT.md content, truncated if too long)
   - roadmapMd?: string (ROADMAP.md content)
   - stateMd?: string (STATE.md content)
   - currentPhase?: string (parsed from STATE.md)
   - issues?: string[] (parsed from ISSUES.md if exists)

2. Create async function getProjectContext(): Promise<ProjectContext>
   - Get workspace folder via vscode.workspace.workspaceFolders
   - Check if .planning directory exists
   - If exists, read PROJECT.md, ROADMAP.md, STATE.md using vscode.workspace.fs.readFile
   - Parse STATE.md to extract current phase number
   - Return populated ProjectContext including URIs for reference display
   - Handle missing files gracefully (undefined values)

3. Create function formatContextForPrompt(ctx: ProjectContext): string
   - Format context as markdown for inclusion in LLM prompts
   - Include relevant sections based on what exists
   - Truncate large files to ~2000 chars with "..." indicator (Pitfall 4 - token limits)
   - Return formatted string

4. Create function truncateContent(content: string, maxLength: number = 2000): string
   - Utility to truncate with "...\n[truncated]" indicator
   - Used by formatContextForPrompt

5. Export all functions

Use vscode.Uri.joinPath for path construction. Handle errors gracefully - missing files should not throw.
  </action>
  <verify>npm run compile succeeds</verify>
  <done>Context provider module exists with getProjectContext, formatContextForPrompt, and truncateContent functions</done>
</task>

<task type="auto">
  <name>Task 2: Add context to CommandContext and update types</name>
  <files>src/chat/commands/types.ts, src/chat/specflowParticipant.ts</files>
  <action>
Update command infrastructure to include project context:

1. In types.ts:
   - Import ProjectContext from '../context/projectContext'
   - Add projectContext: ProjectContext to CommandContext interface

2. In specflowParticipant.ts:
   - Import getProjectContext, formatContextForPrompt from './context/projectContext'
   - Show progress while loading: `stream.progress('Loading project context...')`
   - Before calling command handler, fetch context: const projectContext = await getProjectContext()
   - Include projectContext in CommandContext when calling handlers
   - For general prompts (no command), include formatted context in User message (not System - not supported)

3. Update the general assistance case:
   - If project context exists, add to prompt as User message: "The user is working on a project with SpecFlow planning. Here is the current state: {formatted context}"
   - This helps the model give contextual responses even without specific commands

4. For conversation history awareness (Pattern 3 from research):
   - Access previous responses via `context.history`
   - Consider including recent history in prompts for follow-up questions
   - Implement basic truncation to avoid token limit issues (Pitfall 4)
  </action>
  <verify>npm run compile succeeds</verify>
  <done>CommandContext includes projectContext, participant fetches context before routing with progress indicator</done>
</task>

<task type="auto">
  <name>Task 3: Update /help and add /status command</name>
  <files>src/chat/commands/index.ts, package.json</files>
  <action>
Enhance commands to use context:

1. In package.json, add new command to chatParticipants commands array:
   - { "name": "status", "description": "Show current project status and phase" }

2. In commands/index.ts:
   - Import formatContextForPrompt from '../context/projectContext'
   - Update /help handler to show different message if no .planning folder:
     - If !ctx.projectContext.hasPlanning: "No SpecFlow project found. Use /new-project to initialize."
     - Otherwise show full command list with stream.button() for actions

3. Create /status handler that:
   - Checks if projectContext.hasPlanning
   - If no: stream.markdown("No SpecFlow project found in this workspace.")
     - Use stream.button() for "New Project" action (not markdown link - Pitfall 5)
   - If yes: stream formatted project status including:
     - Project name (from PROJECT.md header)
     - Current phase and plan (from STATE.md)
     - Progress percentage
     - Recent activity
   - Use `stream.reference(projectContext.workspaceUri.with({ path: '.../.planning/STATE.md' }))` for clickable file links (Don't Hand-Roll)
   - Use `stream.filetree()` to show .planning folder structure (Don't Hand-Roll)
   - Use markdown formatting for nice display
   - Return { metadata: { lastCommand: 'status', phaseNumber: ctx.projectContext.currentPhase } }
  </action>
  <verify>npm run compile succeeds, @specflow /status shows project context with clickable file references, @specflow /help adapts to project state</verify>
  <done>/status command shows project context with clickable references and file tree, /help adapts based on project existence</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] Extension loads in Extension Development Host
- [ ] In workspace WITHOUT .planning: @specflow /status shows "No project" message with button
- [ ] In workspace WITHOUT .planning: @specflow /help shows initialization suggestion
- [ ] In workspace WITH .planning: @specflow /status shows project state
- [ ] In workspace WITH .planning: @specflow /status shows clickable file references (clicking opens file)
- [ ] In workspace WITH .planning: @specflow /status shows file tree of .planning folder
- [ ] In workspace WITH .planning: @specflow /help shows full command list
- [ ] General @specflow prompts include project context in responses
- [ ] Progress indicator shows while loading context
- [ ] Long files are truncated (~2000 chars) to avoid token limits
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Context provider reads .planning files correctly
- Commands adapt behavior based on project existence
- /status provides useful project overview with clickable file references and file tree
- stream.reference() used for file links (not markdown links)
- stream.filetree() used for folder display (not ASCII tree)
- stream.button() used for actions (not markdown command links)
- Content truncation prevents token limit issues
- Phase 2: Chat Participant complete
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-participant/02-03-SUMMARY.md`
</output>
