---
phase: 02-chat-participant
plan: 02
type: execute
---

<objective>
Implement slash command routing infrastructure for @specflow participant.

Purpose: Create the command routing system that maps /command invocations to handlers, preparing for Phase 3 (planning commands) and beyond.
Output: Working slash commands in @specflow that route to placeholder handlers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:
@.planning/phases/02-chat-participant/02-01-SUMMARY.md

# Key source files:
@src/chat/specflowParticipant.ts
@package.json

**Tech stack available:**
- VSCode Chat Participants API with commands
- TypeScript ^5.6.3

**Established patterns:**
- Chat participant handler with request.command access
- Stream responses via stream.markdown()

**Discovery (VSCode Chat Commands):**
- Commands defined in package.json chatParticipants[].commands array
- Each command: { name: string, description: string }
- Access via request.command in handler (string or undefined)
- User invokes via @specflow /command-name prompt

**Key Patterns from Research:**
- Route commands via `if (request.command)` pattern before default handling
- Each command handler receives same signature: (request, context, stream, token)
- Return ISpecflowResult with metadata.lastCommand for follow-up provider context
- Use `stream.button()` for clickable action buttons (not markdown command links - Pitfall 5)
- One participant with slash commands (not multiple participants - Anti-pattern from research)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define slash commands in package.json</name>
  <files>package.json</files>
  <action>
Add commands array to the chatParticipants contribution for specflow.chat-participant.

Define these commands (matching GSD framework commands for Phase 3+):
1. new-project - "Initialize a new project with PROJECT.md"
2. create-roadmap - "Create roadmap with phases for the project"
3. plan-phase - "Create detailed execution plan for a phase"
4. execute-plan - "Execute a PLAN.md file"
5. progress - "Check project progress and current state"
6. help - "Show available SpecFlow commands"

Format each as: { "name": "command-name", "description": "Brief description" }

Use kebab-case for command names (not camelCase) - this matches VSCode conventions.
  </action>
  <verify>npm run compile succeeds, extension loads without errors</verify>
  <done>package.json chatParticipants has commands array with 6 commands defined</done>
</task>

<task type="auto">
  <name>Task 2: Create command router and placeholder handlers</name>
  <files>src/chat/commands/index.ts, src/chat/commands/types.ts</files>
  <action>
Create command routing infrastructure:

1. Create src/chat/commands/types.ts:
   - Import ISpecflowResult from '../specflowParticipant' (or define locally)
   - Define CommandContext interface with: request, context, stream, token, licenseValidator
   - Define CommandHandler type: (ctx: CommandContext) => Promise<ISpecflowResult>
   - Define CommandRegistry type: Map<string, CommandHandler>

2. Create src/chat/commands/index.ts:
   - Import types
   - Create registry Map with placeholder handlers for each command
   - Each placeholder handler: stream.markdown(`**/${commandName}** - Coming in Phase 3!\n\nThis command will ${description}.`)
   - Exception: /help handler should list all available commands with descriptions
   - Export getCommandHandler(name: string): CommandHandler | undefined
   - Export isValidCommand(name: string): boolean

The /help handler should output formatted markdown listing all commands AND use stream.button() for clickable actions (not markdown links - Pitfall 5 from research):
```typescript
stream.markdown('## SpecFlow Commands\n\n');
stream.markdown('- **/new-project** - Initialize a new project with PROJECT.md\n');
// ... etc
stream.markdown('\n**Quick Actions:**\n');
stream.button({ command: 'specflow.newProject', title: 'New Project' });
```

**Important:** Each handler must return ISpecflowResult with metadata.lastCommand set:
```typescript
return { metadata: { lastCommand: 'help' } };
```
This enables the followupProvider to suggest contextual next actions.
  </action>
  <verify>npm run compile succeeds</verify>
  <done>Command router infrastructure exists with placeholder handlers returning proper metadata</done>
</task>

<task type="auto">
  <name>Task 3: Integrate command routing into chat participant</name>
  <files>src/chat/specflowParticipant.ts</files>
  <action>
Modify the chat participant handler to route commands:

1. Import getCommandHandler, isValidCommand from './commands'

2. In the handler, after license check passes:
   - Check if request.command is defined
   - If so, get handler via getCommandHandler(request.command)
   - If handler exists, call it with CommandContext and return the ISpecflowResult
   - If command unknown, stream.markdown error message and return { metadata: { lastCommand: 'error' } }

3. If no command (just @specflow with prompt):
   - Keep existing behavior: forward to model for general assistance
   - Add context as User message (not System - not supported): "You are SpecFlow, a planning assistant. Help the user understand the GSD framework or suggest appropriate commands."
   - Return { metadata: { lastCommand: undefined } }

4. Handle edge case: If command exists but not implemented yet, still show placeholder message.

5. Update followupProvider to use result.metadata.lastCommand for contextual suggestions:
   ```typescript
   provideFollowups(result, context, token) {
     const lastCmd = result.metadata?.lastCommand;
     if (lastCmd === 'help') {
       return [{ prompt: '/new-project', label: 'Start new project' }];
     }
     // Default suggestions
     return [{ prompt: '/help', label: 'Show commands' }];
   }
   ```

Update imports and ensure CommandContext is properly constructed from handler parameters.
  </action>
  <verify>npm run compile succeeds, @specflow /help shows command list, @specflow /new-project shows placeholder, follow-ups adapt based on last command</verify>
  <done>Chat participant routes commands to handlers, /help works, placeholders show for unimplemented commands, follow-ups are contextual</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] Extension loads in Extension Development Host
- [ ] @specflow /help lists all 6 commands with descriptions
- [ ] @specflow /help shows clickable action buttons (not just text links)
- [ ] @specflow /new-project shows "Coming in Phase 3" placeholder
- [ ] @specflow /create-roadmap shows placeholder
- [ ] @specflow without command responds with general assistance
- [ ] Unknown command @specflow /invalid shows error message
- [ ] Follow-up suggestions change based on last command used
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Command routing works correctly
- /help provides useful command list with clickable buttons
- Placeholders ready for Phase 3 implementation
- All handlers return ISpecflowResult with metadata.lastCommand
- Follow-up provider uses lastCommand for contextual suggestions
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-participant/02-02-SUMMARY.md`
</output>
