---
phase: 02-chat-participant
plan: 02
type: execute
---

<objective>
Implement slash command routing infrastructure for @specflow participant.

Purpose: Create the command routing system that maps /command invocations to handlers, preparing for Phase 3 (planning commands) and beyond.
Output: Working slash commands in @specflow that route to placeholder handlers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:
@.planning/phases/02-chat-participant/02-01-SUMMARY.md

# Key source files:
@src/chat/specflowParticipant.ts
@package.json

**Tech stack available:**
- VSCode Chat Participants API with commands
- TypeScript ^5.6.3

**Established patterns:**
- Chat participant handler with request.command access
- Stream responses via stream.markdown()

**Discovery (VSCode Chat Commands):**
- Commands defined in package.json chatParticipants[].commands array
- Each command: { name: string, description: string }
- Access via request.command in handler (string or undefined)
- User invokes via @specflow /command-name prompt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define slash commands in package.json</name>
  <files>package.json</files>
  <action>
Add commands array to the chatParticipants contribution for specflow.chat-participant.

Define these commands (matching GSD framework commands for Phase 3+):
1. new-project - "Initialize a new project with PROJECT.md"
2. create-roadmap - "Create roadmap with phases for the project"
3. plan-phase - "Create detailed execution plan for a phase"
4. execute-plan - "Execute a PLAN.md file"
5. progress - "Check project progress and current state"
6. help - "Show available SpecFlow commands"

Format each as: { "name": "command-name", "description": "Brief description" }

Use kebab-case for command names (not camelCase) - this matches VSCode conventions.
  </action>
  <verify>npm run compile succeeds, extension loads without errors</verify>
  <done>package.json chatParticipants has commands array with 6 commands defined</done>
</task>

<task type="auto">
  <name>Task 2: Create command router and placeholder handlers</name>
  <files>src/chat/commands/index.ts, src/chat/commands/types.ts</files>
  <action>
Create command routing infrastructure:

1. Create src/chat/commands/types.ts:
   - Define CommandContext interface with: request, context, stream, token, licenseValidator
   - Define CommandHandler type: (ctx: CommandContext) => Promise<void>
   - Define CommandRegistry type: Map<string, CommandHandler>

2. Create src/chat/commands/index.ts:
   - Import types
   - Create registry Map with placeholder handlers for each command
   - Each placeholder handler: stream.markdown(`ðŸš§ **/${commandName}** - Coming in Phase 3!\\n\\nThis command will ${description}.`)
   - Exception: /help handler should list all available commands with descriptions
   - Export getCommandHandler(name: string): CommandHandler | undefined
   - Export isValidCommand(name: string): boolean

The /help handler should output formatted markdown listing all commands:
```
## SpecFlow Commands

- **/new-project** - Initialize a new project with PROJECT.md
- **/create-roadmap** - Create roadmap with phases for the project
... etc
```
  </action>
  <verify>npm run compile succeeds</verify>
  <done>Command router infrastructure exists with placeholder handlers</done>
</task>

<task type="auto">
  <name>Task 3: Integrate command routing into chat participant</name>
  <files>src/chat/specflowParticipant.ts</files>
  <action>
Modify the chat participant handler to route commands:

1. Import getCommandHandler, isValidCommand from './commands'

2. In the handler, after license check passes:
   - Check if request.command is defined
   - If so, get handler via getCommandHandler(request.command)
   - If handler exists, call it with CommandContext and return
   - If command unknown, stream.markdown error message

3. If no command (just @specflow with prompt):
   - Keep existing behavior: forward to model for general assistance
   - Add system context: "You are SpecFlow, a planning assistant. Help the user understand the GSD framework or suggest appropriate commands."

4. Handle edge case: If command exists but not implemented yet, still show placeholder message.

Update imports and ensure CommandContext is properly constructed from handler parameters.
  </action>
  <verify>npm run compile succeeds, @specflow /help shows command list, @specflow /new-project shows placeholder</verify>
  <done>Chat participant routes commands to handlers, /help works, placeholders show for unimplemented commands</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run compile` succeeds without errors
- [ ] Extension loads in Extension Development Host
- [ ] @specflow /help lists all 6 commands with descriptions
- [ ] @specflow /new-project shows "Coming in Phase 3" placeholder
- [ ] @specflow /create-roadmap shows placeholder
- [ ] @specflow without command responds with general assistance
- [ ] Unknown command @specflow /invalid shows error message
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Command routing works correctly
- /help provides useful command list
- Placeholders ready for Phase 3 implementation
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-participant/02-02-SUMMARY.md`
</output>
