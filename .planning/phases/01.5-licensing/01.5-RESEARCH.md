# Phase 1.5: Licensing - Research

**Researched:** 2026-01-12
**Domain:** Freemium licensing with on-chain storage and dual payment rails (Stripe + crypto)
**Confidence:** HIGH

<research_summary>
## Summary

Researched the technology stack for implementing a freemium license system with NEAR on-chain storage and dual payment rails (Stripe subscriptions + x402/NEAR Intents crypto payments).

The standard approach uses:
1. **NEAR Smart Contract** (Rust) for license storage - simple LookupMap of account_id to subscription_expiry timestamp
2. **Stripe** for traditional subscription payments with webhook handlers for lifecycle events
3. **x402** for instant crypto micropayments over HTTP (Coinbase protocol, supports NEAR)
4. **NEAR Intents** for cross-chain token acceptance - convert any token to USDC via 1Click API

**Primary recommendation:** Start with Stripe + NEAR contract (simplest path to revenue), add x402 for crypto-native users. NEAR Intents enables "pay with any token" but adds complexity - consider Phase 2 addition.
</research_summary>

<standard_stack>
## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| near-sdk-rs | 5.x | NEAR smart contract SDK | Official Rust SDK, modern `near_sdk::store` collections |
| stripe | 17.x | Stripe Node.js SDK | Official SDK with TypeScript support |
| @x402/express | latest | x402 middleware | Official Coinbase SDK for HTTP payments |
| @defuse-protocol/one-click-sdk-typescript | latest | NEAR Intents | Simplified cross-chain swap API |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| cargo-near | latest | NEAR contract build tool | Building and deploying contracts |
| near-cli-rs | latest | NEAR CLI | Contract deployment, testing |
| stripe-cli | latest | Stripe local testing | Webhook forwarding during dev |
| near-api-js | 5.x | NEAR JavaScript API | Calling contract from backend |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| NEAR contract | Database-only | DB is simpler but not verifiable on-chain; NEAR provides proof of license |
| x402 | Custom crypto checkout | x402 is standardized, has ecosystem momentum; custom means more work |
| NEAR Intents | Single-token acceptance | Intents enables any token but adds complexity; start with USDC-only |
| Stripe | Paddle/LemonSqueezy | Stripe has best docs/ecosystem; others handle more tax compliance |

**Installation:**
```bash
# Rust toolchain for NEAR contract
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
rustup target add wasm32-unknown-unknown
cargo install cargo-near

# Node.js dependencies
npm install stripe @x402/core @x402/express @x402/evm near-api-js
npm install @defuse-protocol/one-click-sdk-typescript
```
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended Project Structure
```
specflow/
├── contracts/
│   └── license/           # NEAR Rust contract
│       ├── Cargo.toml
│       └── src/
│           └── lib.rs     # LookupMap<AccountId, u64> (expiry timestamp)
├── src/
│   ├── licensing/
│   │   ├── stripe.ts      # Stripe webhook handler
│   │   ├── x402.ts        # x402 payment middleware
│   │   ├── near-intents.ts # NEAR Intents integration
│   │   ├── contract.ts    # NEAR contract client
│   │   └── validator.ts   # License check logic
│   └── extension.ts       # VSCode extension entry
└── webhook-server/        # Separate webhook endpoint (optional)
```

### Pattern 1: NEAR License Contract
**What:** Simple storage contract mapping account_id to subscription_expiry timestamp
**When to use:** Always - this is the on-chain source of truth
**Example:**
```rust
// Source: NEAR SDK docs + best practices
use near_sdk::store::LookupMap;
use near_sdk::{near, AccountId, env, NearToken};

#[near(contract_state)]
pub struct LicenseContract {
    licenses: LookupMap<AccountId, u64>,  // account -> expiry_timestamp_ns
    admin: AccountId,
}

#[near]
impl LicenseContract {
    #[init]
    pub fn new(admin: AccountId) -> Self {
        Self {
            licenses: LookupMap::new(b"l"),
            admin,
        }
    }

    // Called by webhook handler after successful payment
    pub fn grant_license(&mut self, account_id: AccountId, duration_days: u32) {
        require!(env::predecessor_account_id() == self.admin, "Unauthorized");
        let current = self.licenses.get(&account_id).copied().unwrap_or(env::block_timestamp());
        let new_expiry = current + (duration_days as u64 * 24 * 60 * 60 * 1_000_000_000);
        self.licenses.insert(account_id, new_expiry);
    }

    pub fn is_licensed(&self, account_id: &AccountId) -> bool {
        self.licenses.get(account_id)
            .map(|expiry| *expiry > env::block_timestamp())
            .unwrap_or(false)
    }

    pub fn get_expiry(&self, account_id: &AccountId) -> Option<u64> {
        self.licenses.get(account_id).copied()
    }
}
```

### Pattern 2: Stripe Webhook Handler
**What:** Express endpoint receiving Stripe subscription events, updating NEAR contract
**When to use:** Processing Stripe subscription lifecycle
**Example:**
```typescript
// Source: Stripe docs
import Stripe from 'stripe';
import { connect, Contract } from 'near-api-js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!);

export async function handleStripeWebhook(req: Request, res: Response) {
    const sig = req.headers['stripe-signature']!;
    const event = stripe.webhooks.constructEvent(
        req.body,  // raw body
        sig,
        process.env.STRIPE_WEBHOOK_SECRET!
    );

    switch (event.type) {
        case 'invoice.paid': {
            const invoice = event.data.object as Stripe.Invoice;
            const customerId = invoice.customer as string;
            const nearAccountId = await getNearAccountForStripeCustomer(customerId);
            await grantLicenseOnChain(nearAccountId, 30); // 30 days
            break;
        }
        case 'customer.subscription.deleted': {
            // License naturally expires; no action needed
            break;
        }
    }

    res.json({ received: true });
}
```

### Pattern 3: x402 Payment Endpoint
**What:** HTTP endpoint that returns 402 for unlicensed users, accepts crypto payment
**When to use:** Crypto-native payment option
**Example:**
```typescript
// Source: x402 GitHub
import { paymentMiddleware } from '@x402/express';

app.use(
    '/api/premium',
    paymentMiddleware({
        "GET /feature": {
            price: "$5.00",
            network: "base-sepolia",  // or "near"
            config: {
                description: "SpecFlow Pro License (30 days)"
            }
        }
    }),
    async (req, res) => {
        // Payment verified by middleware
        const payerAddress = req.paymentPayload?.payer;
        await grantLicenseOnChain(payerAddress, 30);
        res.json({ success: true, license: { days: 30 } });
    }
);
```

### Anti-Patterns to Avoid
- **Storing license in extension state only:** Extension state is local; use NEAR contract as source of truth
- **Calling NEAR contract on every operation:** Cache license status locally with TTL (e.g., 1 hour)
- **Trusting client-side license checks:** Always verify on backend/contract before premium operations
- **Hard-coding prices in contract:** Keep pricing in backend/config for flexibility
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Webhook signature verification | Custom HMAC | `stripe.webhooks.constructEvent()` | Edge cases in timing, encoding; Stripe handles it |
| Crypto payment flow | Custom blockchain integration | x402 protocol | Standardized, audited, ecosystem support |
| Cross-chain token swaps | Direct DEX integration | NEAR Intents 1Click API | Solver network handles routing, slippage, MEV |
| Subscription lifecycle | Custom state machine | Stripe Billing | Dunning, retries, prorations handled by Stripe |
| Contract access control | Custom role system | NEAR `require!` + admin pattern | Simple admin check is sufficient for this use case |

**Key insight:** Payment systems have been solved many times over. Stripe's webhook system handles edge cases like duplicate events, retries, and signature verification. x402 handles crypto payment verification and settlement. NEAR Intents handles cross-chain complexity. Don't rebuild these - focus on the license storage and validation logic.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Webhook Idempotency
**What goes wrong:** Processing the same Stripe event twice grants double license duration
**Why it happens:** Stripe retries webhooks on failures; network issues cause duplicates
**How to avoid:** Store processed event IDs, check before processing. Use `event.id` as idempotency key.
**Warning signs:** Users reporting license duration longer than purchased

### Pitfall 2: Raw Body Parsing
**What goes wrong:** Stripe signature verification fails with "Invalid signature"
**Why it happens:** JSON body parsers modify the raw request body; signature was computed on raw bytes
**How to avoid:** Use `express.raw({ type: 'application/json' })` for webhook endpoint BEFORE json parser
**Warning signs:** All webhook signature verifications fail

### Pitfall 3: NEAR Storage Costs
**What goes wrong:** Contract runs out of storage deposit, transactions fail
**Why it happens:** Each account entry costs ~0.01 NEAR; not budgeted for scale
**How to avoid:** Use short prefixes (single char), estimate max users, maintain storage buffer
**Warning signs:** "StorageExceeded" errors on contract calls

### Pitfall 4: Clock Drift in Expiry Checks
**What goes wrong:** Users lose access slightly before expected expiry
**Why it happens:** Comparing local timestamps with contract timestamps
**How to avoid:** Use NEAR's `env::block_timestamp()` as source of truth; add grace period (1 hour)
**Warning signs:** User complaints about premature expiry near renewal time

### Pitfall 5: x402 Network Mismatch
**What goes wrong:** Payment accepted on wrong network (testnet vs mainnet)
**Why it happens:** Environment config doesn't match facilitator config
**How to avoid:** Explicit network configuration; different endpoints for test/prod
**Warning signs:** Payments appear successful but funds don't arrive

### Pitfall 6: Missing Customer Metadata
**What goes wrong:** Can't link Stripe customer to NEAR account after payment
**Why it happens:** Forgot to store NEAR account_id in Stripe customer metadata
**How to avoid:** Always set `metadata.near_account_id` when creating Stripe customer
**Warning signs:** Successful payments with no license grants
</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official sources:

### NEAR Contract Initialization
```rust
// Source: NEAR SDK docs
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct LicenseContract {
    licenses: LookupMap<AccountId, u64>,
    admin: AccountId,
}

impl Default for LicenseContract {
    fn default() -> Self {
        env::panic_str("Contract must be initialized with new()")
    }
}
```

### Stripe Customer Creation with Metadata
```typescript
// Source: Stripe API docs
const customer = await stripe.customers.create({
    email: userEmail,
    metadata: {
        near_account_id: nearAccountId,  // Critical for linking
        source: 'specflow_extension'
    }
});

const session = await stripe.checkout.sessions.create({
    customer: customer.id,
    mode: 'subscription',
    line_items: [{
        price: process.env.STRIPE_PRICE_ID,  // Price object, not amount
        quantity: 1
    }],
    success_url: `${baseUrl}/success?session_id={CHECKOUT_SESSION_ID}`,
    cancel_url: `${baseUrl}/cancel`
});
```

### Stripe Webhook Raw Body Setup (Express)
```typescript
// Source: Stripe webhooks docs
// MUST be before express.json() middleware
app.post('/webhook/stripe',
    express.raw({ type: 'application/json' }),
    handleStripeWebhook
);

// Other routes can use JSON parser
app.use(express.json());
```

### x402 Client Payment Flow
```typescript
// Source: x402 GitHub
import { wrapFetch } from '@x402/fetch';
import { createWalletClient } from 'viem';

const wallet = createWalletClient({ /* config */ });
const fetch402 = wrapFetch(fetch, wallet);

// Automatic payment on 402 response
const response = await fetch402('https://api.specflow.io/premium/feature');
const data = await response.json();
```

### NEAR Intents 1Click Swap
```typescript
// Source: defuse-protocol SDK docs
import { OneClickSDK } from '@defuse-protocol/one-click-sdk-typescript';

const sdk = new OneClickSDK({ jwt: process.env.NEAR_INTENTS_JWT });

// Get quote for any token -> USDC
const quote = await sdk.getQuote({
    fromToken: 'near:wrap.near',  // User's token
    toToken: 'base:usdc',         // Settlement token
    amount: '5000000000000000000000000',  // 5 NEAR
    slippage: 0.5
});

// User sends to deposit address
const depositAddress = quote.depositAddress;
// After confirmation, USDC arrives at your address
```

### License Validation Cache
```typescript
// Source: Common pattern
interface LicenseCache {
    isLicensed: boolean;
    expiresAt: number;
    cachedAt: number;
}

const LICENSE_CACHE_TTL = 60 * 60 * 1000; // 1 hour

async function checkLicense(accountId: string): Promise<boolean> {
    const cached = licenseCache.get(accountId);
    if (cached && Date.now() - cached.cachedAt < LICENSE_CACHE_TTL) {
        return cached.isLicensed;
    }

    const expiry = await contract.get_expiry({ account_id: accountId });
    const isLicensed = expiry ? expiry > Date.now() * 1_000_000 : false;

    licenseCache.set(accountId, {
        isLicensed,
        expiresAt: expiry || 0,
        cachedAt: Date.now()
    });

    return isLicensed;
}
```
</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| `near_sdk::collections` | `near_sdk::store` | 2024 | New API, better performance, collections deprecated |
| Stripe API 2023-xx | API 2025-06-30.basil | 2025 | New billing mode, TypeScript improvements |
| Custom crypto checkout | x402 protocol | May 2025 | Standardized HTTP-native payments, ecosystem adoption |
| Manual bridge swaps | NEAR Intents | Q1 2025 | Intent-based cross-chain, solver competition |
| near-api-js 4.x | near-api-js 5.x | 2025 | Modern API, better TypeScript support |

**New tools/patterns to consider:**
- **x402 V2:** Adds wallet identity, dynamic recipients, CAIP standards (September 2025)
- **NEAR Intents 1Click:** Simplified API for cross-chain without complex intent construction
- **Stripe Flexible Billing:** New `billing_mode[type]` for modern subscription handling

**Deprecated/outdated:**
- **near_sdk::collections:** Use `near_sdk::store` with `legacy` feature only for migration
- **Manual webhook signature verification:** Always use `stripe.webhooks.constructEvent()`
- **Custom cross-chain bridges:** NEAR Intents handles this with solver network
</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **x402 NEAR Native Support Status**
   - What we know: NEAR is listed as supported network, Illia mentioned x402+Intents integration
   - What's unclear: Exact facilitator availability for NEAR native (vs Base/Solana which have Coinbase facilitator)
   - Recommendation: Start with Base (USDC), add NEAR native when facilitator confirmed

2. **NEAR Intents Testnet**
   - What we know: Mainnet is live with $5B+ volume
   - What's unclear: No testnet currently available per docs
   - Recommendation: Use mainnet with small amounts for testing, or mock the API locally

3. **Extension Payment UX**
   - What we know: Can open URLs from extension, can use webviews
   - What's unclear: Best UX for in-extension crypto payments (wallet connect?)
   - Recommendation: Start with redirect to web checkout, iterate on UX later

4. **Gas/Storage Costs at Scale**
   - What we know: ~0.01 NEAR per account storage
   - What's unclear: Cost model at 10k+ users
   - Recommendation: Budget 1 NEAR per 100 users initially, monitor and adjust
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [NEAR SDK Best Practices](https://docs.near.org/smart-contracts/anatomy/best-practices) - Contract patterns, storage
- [NEAR SDK Collections](https://docs.near.org/sdk/rust/contract-structure/collections) - LookupMap usage
- [Stripe Subscription Webhooks](https://docs.stripe.com/billing/subscriptions/webhooks) - Event handling
- [x402 GitHub](https://github.com/coinbase/x402) - Protocol implementation, middleware
- [Coinbase x402 Docs](https://docs.cdp.coinbase.com/x402/welcome) - Official documentation

### Secondary (MEDIUM confidence)
- [NEAR Intents Overview](https://docs.near.org/chain-abstraction/intents/overview) - Architecture
- [1Click SDK TypeScript](https://github.com/defuse-protocol/one-click-sdk-typescript) - Integration guide
- [x402 V2 Launch](https://www.x402.org/writing/x402-v2-launch) - Protocol updates
- NEAR SDK Part 1 Medium article - Practical patterns (October 2025)

### Tertiary (LOW confidence - needs validation)
- x402 NEAR native facilitator availability - mentioned but not confirmed in official docs
- NEAR Intents testnet status - docs say "no testnet currently" but may change
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: NEAR smart contracts (Rust), Stripe Billing, x402 protocol, NEAR Intents
- Ecosystem: near-sdk-rs, stripe npm, x402 npm packages, defuse-protocol SDK
- Patterns: License storage, webhook handling, crypto payments, cross-chain swaps
- Pitfalls: Idempotency, raw body parsing, storage costs, clock drift

**Confidence breakdown:**
- Standard stack: HIGH - all libraries are official/well-documented
- Architecture: HIGH - patterns from official docs and examples
- Pitfalls: HIGH - documented in official docs and common issues
- Code examples: HIGH - from official sources with minor adaptation

**Research date:** 2026-01-12
**Valid until:** 2026-02-12 (30 days - Stripe/NEAR ecosystems stable, x402 evolving)
</metadata>

---

*Phase: 01.5-licensing*
*Research completed: 2026-01-12*
*Ready for planning: yes*
