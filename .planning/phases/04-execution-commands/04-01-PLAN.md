---
phase: 04-execution-commands
plan: 01
type: execute
---

<objective>
Implement the /execute-plan command that reads and executes PLAN.md files.

Purpose: Enable users to execute phase plans by parsing task structure and forwarding tasks to the LLM for implementation, with progress tracking and status reporting.

Output: Working /execute-plan command that:
- Accepts optional path argument (defaults to detecting current phase plan)
- Parses PLAN.md XML task structure
- Executes tasks sequentially via LLM
- Reports progress and task completion status
- Handles cancellation gracefully
</objective>

<execution_context>
Execute tasks sequentially, committing after each task completion.
Follow the plan's verification and success criteria.
Create SUMMARY.md after all tasks complete.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/03-planning-commands/03-03-SUMMARY.md

# Key source files:
@src/chat/commands/index.ts
@src/chat/commands/types.ts
@src/chat/commands/planPhase.ts
@src/chat/generators/planGenerator.ts
@src/chat/generators/types.ts
@src/chat/context/projectContext.ts

**Tech stack available:**
- CommandContext, CommandHandler patterns
- PlanConfig, TaskConfig interfaces
- vscode.ChatResponseStream for progress/markdown/buttons
- vscode.LanguageModelChatMessage for LLM requests

**Established patterns:**
- Command handlers return IHopperResult
- Progress indicators via stream.progress()
- File references via stream.reference()
- LLM requests via request.model.sendRequest()
- JSON extraction from markdown code blocks
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plan executor service module</name>
  <files>src/chat/executor/types.ts, src/chat/executor/planParser.ts, src/chat/executor/index.ts</files>
  <action>
Create new executor module for parsing and tracking plan execution:

1. In src/chat/executor/types.ts, add:
   - ExecutionTask: parsed task with status tracking
     { id: number, name: string, type: TaskConfig['type'], files?: string[], action: string, verify: string, done: string, status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped' }
   - ExecutionPlan: parsed plan with metadata
     { phase: string, planNumber: number, objective: string, purpose: string, tasks: ExecutionTask[], verification: string[], successCriteria: string[] }
   - ExecutionResult: result of task execution
     { taskId: number, success: boolean, output?: string, error?: string }

2. In src/chat/executor/planParser.ts:
   - parsePlanMd(content: string): ExecutionPlan | null
     Parse PLAN.md content, extract frontmatter, sections, and tasks
   - parseTasksXml(tasksSection: string): ExecutionTask[]
     Extract task elements from <tasks> XML section
   - Use regex to match <task type="..."> elements and nested fields

3. In src/chat/executor/index.ts:
   - Export all types and functions

Parsing approach:
- Extract YAML frontmatter between --- markers
- Find <objective>, <tasks>, <verification>, <success_criteria> sections
- Parse tasks using XML-like patterns (task elements with nested name/files/action/verify/done)
- Handle both single-line and multi-line content within elements

Avoid: Don't use a full XML parser - simple regex matching is sufficient for our structured format.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- types.ts exports ExecutionTask, ExecutionPlan, ExecutionResult
- planParser.ts exports parsePlanMd, parseTasksXml
- Parsing extracts all task fields correctly from PLAN.md format
- Module exports work from index.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement /execute-plan command handler</name>
  <files>src/chat/commands/executePlan.ts, src/chat/commands/index.ts</files>
  <action>
Create the /execute-plan command handler:

1. In executePlan.ts, create handleExecutePlan handler:

   Argument parsing:
   - If path provided: use as PLAN.md path (relative to workspace)
   - If no path: detect current phase from STATE.md, find latest PLAN.md

   Plan loading:
   - Read PLAN.md file content
   - Parse using planParser.parsePlanMd()
   - Validate parse succeeded, show error with file reference if not

   Execution loop:
   - Show plan overview (objective, task count)
   - For each task in order:
     a. Show task name and status: "Task 1/3: Create database models"
     b. stream.progress('Executing task...')
     c. Build prompt with task details (action, files, verify criteria)
     d. Send to LLM with full context
     e. Stream LLM response to user
     f. Mark task complete, show done criteria

   Cancellation handling:
   - Check token.isCancellationRequested before each task
   - If cancelled, show partial progress and exit gracefully

2. Update index.ts:
   - Import handleExecutePlan
   - Register in command registry, replacing placeholder
   - Keep execute-plan in COMMAND_DEFINITIONS

Prompt structure for each task:
```
You are executing a task from a Hopper plan.

Task: {task.name}
Files to modify: {task.files.join(', ')}

Action:
{task.action}

Verification: {task.verify}
Done when: {task.done}

Please implement this task. Show the code changes needed.
```

Avoid: Don't try to auto-apply code changes - just show the LLM's suggestions. Users apply changes manually or via Copilot Edit.
  </action>
  <verify>
- npm run compile succeeds
- Command registered in index.ts
- In test workspace with PLAN.md, /execute-plan shows task execution
  </verify>
  <done>
- handleExecutePlan registered in command registry
- Handler parses PLAN.md path or auto-detects from STATE.md
- Plan parsed and tasks extracted
- Each task sent to LLM with proper context
- LLM response streamed to user
- Cancellation checked between tasks
  </done>
</task>

<task type="auto">
  <name>Task 3: Add plan detection, license gating, and error handling</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
Enhance command with plan detection, license gating, and robust error handling:

1. Auto-detect plan path:
   - Read STATE.md to get current phase
   - Parse phase number and directory name
   - Look for PLAN.md files in phase directory
   - Select latest unexecuted plan (no matching SUMMARY.md)
   - If no plan found, suggest /plan-phase

2. License gating (Phase 2+ requires Pro):
   - Extract phase number from plan
   - If phase >= 2, check licenseValidator.checkLicense()
   - Show upgrade prompt if not licensed

3. Progress indicators:
   - stream.progress('Loading plan...')
   - stream.progress('Parsing tasks...')
   - stream.progress(`Executing task ${n} of ${total}...`)

4. Error handling:
   - Plan not found: Show "No plan found" with /plan-phase button
   - Parse error: Show specific parsing issue with file reference
   - LLM error: Catch LanguageModelError, offer retry
   - Missing ROADMAP/STATE: Guide user to prerequisites

5. Completion summary:
   - Show completed tasks count
   - Show any skipped/failed tasks
   - Reference PLAN.md for verification criteria
   - Suggest next steps (verify manually, then /progress)

Avoid: Don't mark plan as complete automatically - user verifies manually.
  </action>
  <verify>
- npm run compile succeeds
- Test: /execute-plan with no argument auto-detects plan
- Test: /execute-plan with invalid path shows helpful error
- Test: License check blocks Phase 2+ for free users
  </verify>
  <done>
- Auto-detection finds current phase plan from STATE.md
- License gating enforced for Phase 2+ plans
- Clear progress indicators throughout execution
- All error cases handled with actionable messages
- Completion shows task summary and next steps
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] /execute-plan command registered in commands index
- [ ] Plan parser extracts tasks from PLAN.md format
- [ ] Command executes tasks sequentially via LLM
- [ ] Progress indicators shown for each task
- [ ] Error handling for missing plan, parse errors
- [ ] License gating for Phase 2+ execution
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- /execute-plan command functional end-to-end
- Tasks sent to LLM with proper context
- Users can execute plans and see LLM suggestions for each task
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution-commands/04-01-SUMMARY.md` following the summary template.
</output>
