---
phase: 04-execution-commands
plan: 03
type: execute
---

<objective>
Implement git commit integration and SUMMARY.md generation after plan execution.

Purpose: Provide atomic commits after each task and automatic summary generation when a plan completes, maintaining clean git history and project documentation.

Output: Enhanced execution that:
- Commits changes after each completed task with descriptive messages
- Generates SUMMARY.md when all tasks complete
- Integrates with VSCode source control for commit visibility
</objective>

<execution_context>
Execute tasks sequentially, committing after each task completion.
Follow the plan's verification and success criteria.
Create SUMMARY.md after all tasks complete.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase:
@.planning/phases/04-execution-commands/04-01-PLAN.md
@.planning/phases/04-execution-commands/04-02-PLAN.md

# Key source files:
@src/chat/executor/types.ts
@src/chat/commands/executePlan.ts

# Example summary format:
@.planning/phases/03-planning-commands/03-03-SUMMARY.md

**Tech stack available:**
- ExecutionTask, ExecutionPlan types
- vscode.workspace.fs for file operations
- simple-git or child_process.exec for git commands
- GeneratorResult pattern for file creation

**Established patterns:**
- Atomic commits after each task
- Summary frontmatter with dependency graph
- Commit message format: {type}({phase}-{plan}): {description}
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create git integration service</name>
  <files>src/chat/executor/gitService.ts, src/chat/executor/index.ts</files>
  <action>
Create git service for commit operations:

1. In gitService.ts, implement:
   - checkGitRepo(workspaceUri: Uri): Promise<boolean>
     Check if workspace is a git repository
   - getStagedFiles(workspaceUri: Uri): Promise<string[]>
     Get list of staged files
   - stageAll(workspaceUri: Uri): Promise<void>
     Stage all changes (git add -A)
   - stageFiles(workspaceUri: Uri, files: string[]): Promise<void>
     Stage specific files
   - commit(workspaceUri: Uri, message: string): Promise<{ success: boolean, hash?: string, error?: string }>
     Create commit with message
   - getRecentCommits(workspaceUri: Uri, count: number): Promise<{ hash: string, message: string }[]>
     Get recent commit history for context

2. Implementation approach:
   - Use child_process.exec() with git CLI commands
   - All commands run from workspace root
   - Capture stdout/stderr for error handling
   - Return structured results

3. Commit message format:
   - Pattern: `{type}({phase}-{plan}): {task name}`
   - type: feat (new code), fix (bug fix), refactor (restructure), docs (documentation)
   - Example: `feat(04-01): Create plan executor service module`

4. Update index.ts to export git service functions

Git commands used:
- `git rev-parse --git-dir` - check if git repo
- `git diff --cached --name-only` - staged files
- `git add -A` or `git add <files>` - staging
- `git commit -m "message"` - commit
- `git log --oneline -n {count}` - recent history

Avoid: Don't use git push - only local commits. User pushes when ready.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- gitService.ts exports checkGitRepo, stageAll, stageFiles, commit, getRecentCommits
- Functions use child_process.exec with git CLI
- Error handling returns structured results
- Commit message follows pattern
  </done>
</task>

<task type="auto">
  <name>Task 2: Add commit after each task in execution</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
Integrate git commits into the execution loop:

1. Before execution starts:
   - Check if workspace is a git repo
   - If not, warn user but continue (commits will be skipped)
   - Show "Git integration enabled" or "Git not available"

2. After each auto task completes:
   - Call gitService.stageAll() to stage changes
   - Generate commit message from task:
     - Detect type from task content (feat if creating, fix if fixing, refactor if restructuring)
     - Use task name for description
     - Format: `{type}({phase}-{plan}): {task.name}`
   - Call gitService.commit() with message
   - Show commit result: "Committed: {hash} - {message}"
   - If commit fails (nothing to commit), show info message and continue

3. Handle checkpoint tasks:
   - Don't auto-commit at checkpoints - user may need to make changes
   - After checkpoint approval, offer to commit with "Commit checkpoint" button
   - Include checkpoint description in commit message

4. Add commit option in UI:
   - Show "[Commit Changes]" button after each task
   - Default behavior: auto-commit if enabled in settings
   - User can disable auto-commit via hopper.autoCommit setting

5. Error handling:
   - Git command failure: show error, continue execution
   - No changes to commit: info message, continue
   - Merge conflict: stop and advise user to resolve

Settings integration:
- hopper.autoCommit: boolean (default: true)
- Check vscode.workspace.getConfiguration('hopper').get('autoCommit')

Avoid: Never commit unstaged files automatically - always stage explicitly first.
  </action>
  <verify>
- npm run compile succeeds
- After task execution, git commit created with proper message
- Commit hash shown in output
  </verify>
  <done>
- Git repo check before execution
- Auto-commit after each auto task
- Commit message follows format pattern
- Checkpoint tasks don't auto-commit
- Commit failures handled gracefully
- Auto-commit configurable via settings
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate SUMMARY.md after plan completion</name>
  <files>src/chat/executor/summaryGenerator.ts, src/chat/commands/executePlan.ts</files>
  <action>
Create summary generator and integrate with execution completion:

1. In summaryGenerator.ts, create:
   - SummaryConfig interface: { phase, plan, duration, tasks: ExecutionTask[], commits: string[], filesModified: string[], decisions: Record<string, string>, issues?: string[] }
   - createSummaryMd(config: SummaryConfig): string
   - saveSummary(workspaceUri: Uri, phaseDir: string, config: SummaryConfig): Promise<GeneratorResult>

2. Summary content structure (following existing summaries):
   - YAML frontmatter: phase, plan, subsystem, tags, dependency graph, tech-stack, key-files, key-decisions, issues-created, metrics
   - Markdown body: Performance, Accomplishments, Task Commits, Files Created/Modified, Decisions Made, Deviations from Plan, Issues Encountered, Next Phase Readiness

3. Frontmatter generation:
   - phase: from plan
   - plan: number
   - subsystem: detect from task files (commands, executor, etc.)
   - tags: extract from task names
   - requires: reference prior plan if exists
   - provides: list what this plan delivers
   - affects: predict future phases affected
   - tech-stack.added: any new libraries
   - tech-stack.patterns: patterns established
   - key-files.created: new files from tasks
   - key-files.modified: modified files from tasks
   - key-decisions: from checkpoint:decision choices
   - duration: track execution time
   - completed: ISO timestamp

4. Integration with executePlan:
   - Track start time at execution begin
   - Collect commits as they happen
   - Collect files from task.files arrays
   - After all tasks complete, generate summary
   - Save to phase directory
   - Show success with file reference

5. Final commit:
   - After SUMMARY.md created, commit docs
   - Message: `docs({phase}-{plan}): complete plan summary`

Avoid: Don't update STATE.md - that's handled by /progress in Phase 5.
  </action>
  <verify>
- npm run compile succeeds
- After plan completion, SUMMARY.md created in phase directory
- Summary includes frontmatter and all sections
- Final docs commit created
  </verify>
  <done>
- summaryGenerator.ts exports createSummaryMd, saveSummary
- Summary follows existing format with frontmatter
- Duration tracked from execution start
- Commits and files collected during execution
- SUMMARY.md saved to phase directory
- Final commit for documentation
- File reference shown to user
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] Git service functions work (stage, commit)
- [ ] Commits created after each task execution
- [ ] Commit messages follow format pattern
- [ ] SUMMARY.md generated after plan completion
- [ ] Summary includes frontmatter and all sections
- [ ] Docs commit created for summary
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Git integration creates atomic commits per task
- SUMMARY.md generated with proper structure
- Phase 4: Execution Commands complete after this plan
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution-commands/04-03-SUMMARY.md` following the summary template.

Note: This is the final plan in Phase 4. After summary creation, the phase is complete and ready for Phase 5 (Session Management).
</output>
