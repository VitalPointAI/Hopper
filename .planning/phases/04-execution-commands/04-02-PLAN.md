---
phase: 04-execution-commands
plan: 02
type: execute
---

<objective>
Implement verification criteria checking and checkpoint handling during plan execution.

Purpose: Ensure tasks meet their acceptance criteria before proceeding, and handle checkpoint tasks that require user interaction (verification or decision).

Output: Enhanced execution flow that:
- Runs verification checks after each auto task
- Pauses at checkpoint:human-verify tasks for user confirmation
- Presents options at checkpoint:decision tasks and waits for selection
- Tracks verification status and reports results
</objective>

<execution_context>
Execute tasks sequentially, committing after each task completion.
Follow the plan's verification and success criteria.
Create SUMMARY.md after all tasks complete.
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan in this phase:
@.planning/phases/04-execution-commands/04-01-PLAN.md

# Key source files (after 04-01):
@src/chat/executor/types.ts
@src/chat/executor/planParser.ts
@src/chat/commands/executePlan.ts

**Tech stack available:**
- ExecutionTask, ExecutionPlan, ExecutionResult types
- planParser for PLAN.md parsing
- vscode.ChatResponseStream for buttons and user interaction
- stream.button() for action buttons

**Established patterns:**
- Checkpoint tasks pause execution
- stream.button() for actionable responses
- IHopperResult metadata for follow-up suggestions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add checkpoint handling to executor types</name>
  <files>src/chat/executor/types.ts, src/chat/executor/planParser.ts</files>
  <action>
Extend types and parsing for checkpoint tasks:

1. In types.ts, add checkpoint-specific types:
   - CheckpointVerifyTask extends base task with:
     { type: 'checkpoint:human-verify', whatBuilt: string, howToVerify: string[], resumeSignal: string }
   - CheckpointDecisionTask extends base task with:
     { type: 'checkpoint:decision', decision: string, context: string, options: { id: string, name: string, pros: string, cons: string }[], resumeSignal: string }
   - ExecutionState: { planPath: string, currentTaskIndex: number, completedTasks: number[], decisions: Record<string, string> }

2. In planParser.ts, update parseTasksXml to:
   - Detect task type from type attribute
   - For checkpoint:human-verify: extract what-built, how-to-verify, resume-signal
   - For checkpoint:decision: extract decision, context, options, resume-signal
   - Return typed tasks based on type

XML patterns to parse:
```xml
<task type="checkpoint:human-verify" gate="blocking">
  <what-built>...</what-built>
  <how-to-verify>
    1. Step one
    2. Step two
  </how-to-verify>
  <resume-signal>...</resume-signal>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>...</decision>
  <context>...</context>
  <options>
    <option id="a"><name>...</name><pros>...</pros><cons>...</cons></option>
  </options>
  <resume-signal>...</resume-signal>
</task>
```

Avoid: Don't try to parse arbitrary XML - match specific patterns from plan template.
  </action>
  <verify>TypeScript compiles without errors: npm run compile</verify>
  <done>
- CheckpointVerifyTask type exported
- CheckpointDecisionTask type exported
- ExecutionState type for tracking progress
- Parser correctly identifies and extracts checkpoint tasks
- All checkpoint fields populated from XML
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement checkpoint handling in execute-plan</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
Add checkpoint task handling to the execution loop:

1. For checkpoint:human-verify tasks:
   - Show what was built (whatBuilt field)
   - Display numbered verification steps (howToVerify)
   - Show "Approve" button that re-invokes /execute-plan to continue
   - Show text input option for describing issues
   - Store execution state in extension globalState

2. For checkpoint:decision tasks:
   - Present the decision context
   - Show options with pros/cons in structured format
   - Add button for each option
   - Store selected decision in execution state
   - Continue execution with decision recorded

3. Execution state management:
   - Store state in context.globalState when paused at checkpoint
   - Key: `hopper.executionState.${planPath}`
   - On /execute-plan resume, check for existing state
   - If state exists and checkpoint was approved, continue from next task

4. Resume logic:
   - Add optional `resume` param detection in prompt
   - If user types "approved" or clicks Approve button after checkpoint
   - Load execution state, continue from next task
   - Clear state when plan completes

Display format for checkpoint:human-verify:
```markdown
## Checkpoint: Verify Implementation

**What was built:** {whatBuilt}

**Please verify:**
1. {step1}
2. {step2}
...

[Approve] [Report Issue]

Type "approved" to continue, or describe any issues.
```

Avoid: Don't auto-approve checkpoints - always require explicit user action.
  </action>
  <verify>
- npm run compile succeeds
- Checkpoint tasks pause execution and show verification UI
- Approve button continues execution
  </verify>
  <done>
- human-verify checkpoints display steps and wait for approval
- decision checkpoints show options with buttons
- Execution state saved when paused
- Resume from checkpoint works after approval
- User can report issues instead of approving
  </done>
</task>

<task type="auto">
  <name>Task 3: Add task verification and execution summary</name>
  <files>src/chat/commands/executePlan.ts</files>
  <action>
Add verification criteria tracking and execution summary:

1. Task verification tracking:
   - After each auto task, show verification criteria
   - Display verify field from task: "Verify: {task.verify}"
   - Display done criteria: "Done when: {task.done}"
   - Mark task visually complete with checkmark

2. Execution progress display:
   - Show progress bar or fraction: "Task 2/5 completed"
   - List completed tasks with checkmarks
   - Show current task with spinner/arrow
   - List remaining tasks dimmed

3. Plan verification section:
   - After all tasks complete, show plan's verification checklist
   - Format as markdown checkbox list (for user to mentally check)
   - Reference PLAN.md for full criteria

4. Execution summary:
   - Total tasks: X completed, Y skipped, Z failed
   - Time elapsed (optional, track start time)
   - Decisions made (if any checkpoint:decision tasks)
   - Files mentioned across tasks (union of all task.files)

5. Next steps after completion:
   - Suggest manual verification of all criteria
   - Suggest /progress to update STATE.md
   - If all phases complete, congratulate and suggest next milestone

Format for progress:
```markdown
## Execution Progress

- [x] Task 1: Create database models
- [>] Task 2: Implement API routes (running)
- [ ] Task 3: Add error handling

---

Currently executing Task 2...
```

Avoid: Don't auto-update STATE.md - that's Phase 5 (session management).
  </action>
  <verify>
- npm run compile succeeds
- Progress display shows task completion status
- Verification criteria shown after tasks
- Summary shown after plan completion
  </verify>
  <done>
- Verification criteria displayed after each task
- Progress indicator shows completion fraction
- Final summary includes task counts and files
- Next steps suggest manual verification and /progress
- No automatic STATE.md updates (Phase 5)
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run compile succeeds without errors
- [ ] Checkpoint:human-verify tasks pause and show approval UI
- [ ] Checkpoint:decision tasks show options and buttons
- [ ] Execution state persisted across checkpoint pauses
- [ ] Resume from checkpoint continues execution
- [ ] Verification criteria shown after each task
- [ ] Completion summary shows task statistics
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Checkpoint tasks properly pause execution
- User can approve or report issues at checkpoints
- Execution summary provides useful completion info
</success_criteria>

<output>
After completion, create `.planning/phases/04-execution-commands/04-02-SUMMARY.md` following the summary template.
</output>
